{"version":3,"file":"flood-map-geocode.js","mappings":"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","sources":["webpack://@defra/flood-map/./node_modules/@turf/invariant/dist/esm/index.js","webpack://@defra/flood-map/./node_modules/@turf/helpers/dist/esm/index.js","webpack://@defra/flood-map/./node_modules/@turf/distance/dist/esm/index.js","webpack://@defra/flood-map/./src/js/provider/os-open-names/geocode.js","webpack://@defra/flood-map/./node_modules/geodesy/dms.js","webpack://@defra/flood-map/./node_modules/geodesy/vector3d.js","webpack://@defra/flood-map/./node_modules/geodesy/latlon-ellipsoidal.js","webpack://@defra/flood-map/./node_modules/geodesy/latlon-ellipsoidal-datum.js","webpack://@defra/flood-map/./node_modules/geodesy/osgridref.js","webpack://@defra/flood-map/./src/js/lib/viewport.js","webpack://@defra/flood-map/./src/js/provider/os-open-names/reverse-geocode.js"],"sourcesContent":["// index.ts\nimport { isNumber } from \"@turf/helpers\";\nfunction getCoord(coord) {\n  if (!coord) {\n    throw new Error(\"coord is required\");\n  }\n  if (!Array.isArray(coord)) {\n    if (coord.type === \"Feature\" && coord.geometry !== null && coord.geometry.type === \"Point\") {\n      return [...coord.geometry.coordinates];\n    }\n    if (coord.type === \"Point\") {\n      return [...coord.coordinates];\n    }\n  }\n  if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {\n    return [...coord];\n  }\n  throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\n}\nfunction getCoords(coords) {\n  if (Array.isArray(coords)) {\n    return coords;\n  }\n  if (coords.type === \"Feature\") {\n    if (coords.geometry !== null) {\n      return coords.geometry.coordinates;\n    }\n  } else {\n    if (coords.coordinates) {\n      return coords.coordinates;\n    }\n  }\n  throw new Error(\n    \"coords must be GeoJSON Feature, Geometry Object or an Array\"\n  );\n}\nfunction containsNumber(coordinates) {\n  if (coordinates.length > 1 && isNumber(coordinates[0]) && isNumber(coordinates[1])) {\n    return true;\n  }\n  if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n    return containsNumber(coordinates[0]);\n  }\n  throw new Error(\"coordinates must only contain numbers\");\n}\nfunction geojsonType(value, type, name) {\n  if (!type || !name) {\n    throw new Error(\"type and name required\");\n  }\n  if (!value || value.type !== type) {\n    throw new Error(\n      \"Invalid input to \" + name + \": must be a \" + type + \", given \" + value.type\n    );\n  }\n}\nfunction featureOf(feature, type, name) {\n  if (!feature) {\n    throw new Error(\"No feature passed\");\n  }\n  if (!name) {\n    throw new Error(\".featureOf() requires a name\");\n  }\n  if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n    throw new Error(\n      \"Invalid input to \" + name + \", Feature with geometry required\"\n    );\n  }\n  if (!feature.geometry || feature.geometry.type !== type) {\n    throw new Error(\n      \"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type\n    );\n  }\n}\nfunction collectionOf(featureCollection, type, name) {\n  if (!featureCollection) {\n    throw new Error(\"No featureCollection passed\");\n  }\n  if (!name) {\n    throw new Error(\".collectionOf() requires a name\");\n  }\n  if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\n    throw new Error(\n      \"Invalid input to \" + name + \", FeatureCollection required\"\n    );\n  }\n  for (const feature of featureCollection.features) {\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n      throw new Error(\n        \"Invalid input to \" + name + \", Feature with geometry required\"\n      );\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n      throw new Error(\n        \"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type\n      );\n    }\n  }\n}\nfunction getGeom(geojson) {\n  if (geojson.type === \"Feature\") {\n    return geojson.geometry;\n  }\n  return geojson;\n}\nfunction getType(geojson, _name) {\n  if (geojson.type === \"FeatureCollection\") {\n    return \"FeatureCollection\";\n  }\n  if (geojson.type === \"GeometryCollection\") {\n    return \"GeometryCollection\";\n  }\n  if (geojson.type === \"Feature\" && geojson.geometry !== null) {\n    return geojson.geometry.type;\n  }\n  return geojson.type;\n}\nexport {\n  collectionOf,\n  containsNumber,\n  featureOf,\n  geojsonType,\n  getCoord,\n  getCoords,\n  getGeom,\n  getType\n};\n//# sourceMappingURL=index.js.map","// index.ts\nvar earthRadius = 63710088e-1;\nvar factors = {\n  centimeters: earthRadius * 100,\n  centimetres: earthRadius * 100,\n  degrees: 360 / (2 * Math.PI),\n  feet: earthRadius * 3.28084,\n  inches: earthRadius * 39.37,\n  kilometers: earthRadius / 1e3,\n  kilometres: earthRadius / 1e3,\n  meters: earthRadius,\n  metres: earthRadius,\n  miles: earthRadius / 1609.344,\n  millimeters: earthRadius * 1e3,\n  millimetres: earthRadius * 1e3,\n  nauticalmiles: earthRadius / 1852,\n  radians: 1,\n  yards: earthRadius * 1.0936\n};\nvar areaFactors = {\n  acres: 247105e-9,\n  centimeters: 1e4,\n  centimetres: 1e4,\n  feet: 10.763910417,\n  hectares: 1e-4,\n  inches: 1550.003100006,\n  kilometers: 1e-6,\n  kilometres: 1e-6,\n  meters: 1,\n  metres: 1,\n  miles: 386e-9,\n  nauticalmiles: 29155334959812285e-23,\n  millimeters: 1e6,\n  millimetres: 1e6,\n  yards: 1.195990046\n};\nfunction feature(geom, properties, options = {}) {\n  const feat = { type: \"Feature\" };\n  if (options.id === 0 || options.id) {\n    feat.id = options.id;\n  }\n  if (options.bbox) {\n    feat.bbox = options.bbox;\n  }\n  feat.properties = properties || {};\n  feat.geometry = geom;\n  return feat;\n}\nfunction geometry(type, coordinates, _options = {}) {\n  switch (type) {\n    case \"Point\":\n      return point(coordinates).geometry;\n    case \"LineString\":\n      return lineString(coordinates).geometry;\n    case \"Polygon\":\n      return polygon(coordinates).geometry;\n    case \"MultiPoint\":\n      return multiPoint(coordinates).geometry;\n    case \"MultiLineString\":\n      return multiLineString(coordinates).geometry;\n    case \"MultiPolygon\":\n      return multiPolygon(coordinates).geometry;\n    default:\n      throw new Error(type + \" is invalid\");\n  }\n}\nfunction point(coordinates, properties, options = {}) {\n  if (!coordinates) {\n    throw new Error(\"coordinates is required\");\n  }\n  if (!Array.isArray(coordinates)) {\n    throw new Error(\"coordinates must be an Array\");\n  }\n  if (coordinates.length < 2) {\n    throw new Error(\"coordinates must be at least 2 numbers long\");\n  }\n  if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n    throw new Error(\"coordinates must contain numbers\");\n  }\n  const geom = {\n    type: \"Point\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction points(coordinates, properties, options = {}) {\n  return featureCollection(\n    coordinates.map((coords) => {\n      return point(coords, properties);\n    }),\n    options\n  );\n}\nfunction polygon(coordinates, properties, options = {}) {\n  for (const ring of coordinates) {\n    if (ring.length < 4) {\n      throw new Error(\n        \"Each LinearRing of a Polygon must have 4 or more Positions.\"\n      );\n    }\n    if (ring[ring.length - 1].length !== ring[0].length) {\n      throw new Error(\"First and last Position are not equivalent.\");\n    }\n    for (let j = 0; j < ring[ring.length - 1].length; j++) {\n      if (ring[ring.length - 1][j] !== ring[0][j]) {\n        throw new Error(\"First and last Position are not equivalent.\");\n      }\n    }\n  }\n  const geom = {\n    type: \"Polygon\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction polygons(coordinates, properties, options = {}) {\n  return featureCollection(\n    coordinates.map((coords) => {\n      return polygon(coords, properties);\n    }),\n    options\n  );\n}\nfunction lineString(coordinates, properties, options = {}) {\n  if (coordinates.length < 2) {\n    throw new Error(\"coordinates must be an array of two or more positions\");\n  }\n  const geom = {\n    type: \"LineString\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction lineStrings(coordinates, properties, options = {}) {\n  return featureCollection(\n    coordinates.map((coords) => {\n      return lineString(coords, properties);\n    }),\n    options\n  );\n}\nfunction featureCollection(features, options = {}) {\n  const fc = { type: \"FeatureCollection\" };\n  if (options.id) {\n    fc.id = options.id;\n  }\n  if (options.bbox) {\n    fc.bbox = options.bbox;\n  }\n  fc.features = features;\n  return fc;\n}\nfunction multiLineString(coordinates, properties, options = {}) {\n  const geom = {\n    type: \"MultiLineString\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction multiPoint(coordinates, properties, options = {}) {\n  const geom = {\n    type: \"MultiPoint\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction multiPolygon(coordinates, properties, options = {}) {\n  const geom = {\n    type: \"MultiPolygon\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction geometryCollection(geometries, properties, options = {}) {\n  const geom = {\n    type: \"GeometryCollection\",\n    geometries\n  };\n  return feature(geom, properties, options);\n}\nfunction round(num, precision = 0) {\n  if (precision && !(precision >= 0)) {\n    throw new Error(\"precision must be a positive number\");\n  }\n  const multiplier = Math.pow(10, precision || 0);\n  return Math.round(num * multiplier) / multiplier;\n}\nfunction radiansToLength(radians, units = \"kilometers\") {\n  const factor = factors[units];\n  if (!factor) {\n    throw new Error(units + \" units is invalid\");\n  }\n  return radians * factor;\n}\nfunction lengthToRadians(distance, units = \"kilometers\") {\n  const factor = factors[units];\n  if (!factor) {\n    throw new Error(units + \" units is invalid\");\n  }\n  return distance / factor;\n}\nfunction lengthToDegrees(distance, units) {\n  return radiansToDegrees(lengthToRadians(distance, units));\n}\nfunction bearingToAzimuth(bearing) {\n  let angle = bearing % 360;\n  if (angle < 0) {\n    angle += 360;\n  }\n  return angle;\n}\nfunction azimuthToBearing(angle) {\n  angle = angle % 360;\n  if (angle > 180) {\n    return angle - 360;\n  } else if (angle < -180) {\n    return angle + 360;\n  }\n  return angle;\n}\nfunction radiansToDegrees(radians) {\n  const normalisedRadians = radians % (2 * Math.PI);\n  return normalisedRadians * 180 / Math.PI;\n}\nfunction degreesToRadians(degrees) {\n  const normalisedDegrees = degrees % 360;\n  return normalisedDegrees * Math.PI / 180;\n}\nfunction convertLength(length, originalUnit = \"kilometers\", finalUnit = \"kilometers\") {\n  if (!(length >= 0)) {\n    throw new Error(\"length must be a positive number\");\n  }\n  return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\nfunction convertArea(area, originalUnit = \"meters\", finalUnit = \"kilometers\") {\n  if (!(area >= 0)) {\n    throw new Error(\"area must be a positive number\");\n  }\n  const startFactor = areaFactors[originalUnit];\n  if (!startFactor) {\n    throw new Error(\"invalid original units\");\n  }\n  const finalFactor = areaFactors[finalUnit];\n  if (!finalFactor) {\n    throw new Error(\"invalid final units\");\n  }\n  return area / startFactor * finalFactor;\n}\nfunction isNumber(num) {\n  return !isNaN(num) && num !== null && !Array.isArray(num);\n}\nfunction isObject(input) {\n  return input !== null && typeof input === \"object\" && !Array.isArray(input);\n}\nfunction validateBBox(bbox) {\n  if (!bbox) {\n    throw new Error(\"bbox is required\");\n  }\n  if (!Array.isArray(bbox)) {\n    throw new Error(\"bbox must be an Array\");\n  }\n  if (bbox.length !== 4 && bbox.length !== 6) {\n    throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n  }\n  bbox.forEach((num) => {\n    if (!isNumber(num)) {\n      throw new Error(\"bbox must only contain numbers\");\n    }\n  });\n}\nfunction validateId(id) {\n  if (!id) {\n    throw new Error(\"id is required\");\n  }\n  if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n    throw new Error(\"id must be a number or a string\");\n  }\n}\nexport {\n  areaFactors,\n  azimuthToBearing,\n  bearingToAzimuth,\n  convertArea,\n  convertLength,\n  degreesToRadians,\n  earthRadius,\n  factors,\n  feature,\n  featureCollection,\n  geometry,\n  geometryCollection,\n  isNumber,\n  isObject,\n  lengthToDegrees,\n  lengthToRadians,\n  lineString,\n  lineStrings,\n  multiLineString,\n  multiPoint,\n  multiPolygon,\n  point,\n  points,\n  polygon,\n  polygons,\n  radiansToDegrees,\n  radiansToLength,\n  round,\n  validateBBox,\n  validateId\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport { getCoord } from \"@turf/invariant\";\nimport { radiansToLength, degreesToRadians } from \"@turf/helpers\";\nfunction distance(from, to, options = {}) {\n  var coordinates1 = getCoord(from);\n  var coordinates2 = getCoord(to);\n  var dLat = degreesToRadians(coordinates2[1] - coordinates1[1]);\n  var dLon = degreesToRadians(coordinates2[0] - coordinates1[0]);\n  var lat1 = degreesToRadians(coordinates1[1]);\n  var lat2 = degreesToRadians(coordinates2[1]);\n  var a = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n  return radiansToLength(\n    2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)),\n    options.units\n  );\n}\nvar turf_distance_default = distance;\nexport {\n  turf_distance_default as default,\n  distance\n};\n//# sourceMappingURL=index.js.map","import OsGridRef from 'geodesy/osgridref.js'\nimport config from './config.json'\n\nconst isPostcode = (value) => {\n  value = value.replace(/\\s/g, '')\n  const regex = /^(([A-Z]{1,2}\\d[A-Z\\d]?|ASCN|STHL|TDCU|BBND|[BFS]IQQ|PCRN|TKCA) ?\\d[A-Z]{2}|BFPO ?\\d{1,4}|(KY\\d|MSR|VG|AI)[ -]?\\d{4}|[A-Z]{2} ?\\d{2}|GE ?CX|GIR ?0A{2}|SAN ?TA1)$/i\n  return regex.test(value)\n}\n\n// Exclude Scotalnd, Wales and Northern Ireland results\nconst removeNonEngland = (results) => {\n  return results.filter(r => r.GAZETTEER_ENTRY.COUNTRY.toLowerCase() === 'england')\n}\n\n// Remove duplicates (OS API bug?) eg: 'Newcastle upon Tyne'\nconst removeDuplicates = (results) => {\n  return Array.from(new Map(results.map(result => [result.GAZETTEER_ENTRY.ID, result])).values())\n}\n\n// Remove any item that doesnt contain a part of the query in name1\nconst removeTenuousResults = (results, query) => {\n  const words = query.toLowerCase().replace(/,/g, '').split(' ')\n  return results.filter(l => words.some(w => l.GAZETTEER_ENTRY.NAME1.toLowerCase().includes(w)))\n}\n\n// Mark search charcaters in result\nconst markString = (string, find) => {\n  find = find.replace(/,/g, '')\n  const patterns = [...new Set([find, ...find.trim().split(/[stn]+/)])].join('|')\n  const reg = new RegExp(`(${patterns})`, 'i', 'g', 'gi')\n  return { __html: string.replace(reg, '<mark>$1</mark>') }\n}\n\nconst place = ({ ID, NAME1, MBR_XMIN, MBR_YMIN, MBR_XMAX, MBR_YMAX, GEOMETRY_X, GEOMETRY_Y }) => {\n  const bounds = MBR_XMIN\n    ? [\n        (new OsGridRef(MBR_XMIN, MBR_YMIN)).toLatLon().lon,\n        (new OsGridRef(MBR_XMIN, MBR_YMIN)).toLatLon().lat,\n        (new OsGridRef(MBR_XMAX, MBR_YMAX)).toLatLon().lon,\n        (new OsGridRef(MBR_XMAX, MBR_YMAX)).toLatLon().lat]\n        .map(n => Math.round(n * 1000000) / 1000000)\n    : [\n        (new OsGridRef(GEOMETRY_X - config.POINT_BUFFER, GEOMETRY_Y - config.POINT_BUFFER)).toLatLon().lon,\n        (new OsGridRef(GEOMETRY_X - config.POINT_BUFFER, GEOMETRY_Y - config.POINT_BUFFER)).toLatLon().lat,\n        (new OsGridRef(GEOMETRY_X + config.POINT_BUFFER, GEOMETRY_Y + config.POINT_BUFFER)).toLatLon().lon,\n        (new OsGridRef(GEOMETRY_X + config.POINT_BUFFER, GEOMETRY_Y + config.POINT_BUFFER)).toLatLon().lat]\n        .map(n => Math.round(n * 1000000) / 1000000)\n  const center = GEOMETRY_X\n    ? [(new OsGridRef(GEOMETRY_X, GEOMETRY_Y)).toLatLon().lon,\n        (new OsGridRef(GEOMETRY_X, GEOMETRY_Y)).toLatLon().lat]\n        .map(n => Math.round(n * 1000000) / 1000000)\n    : null\n\n  return {\n    id: ID,\n    text: NAME1,\n    bounds,\n    center\n  }\n}\n\nconst suggestion = (query, { ID, NAME1, COUNTY_UNITARY, DISTRICT_BOROUGH, POSTCODE_DISTRICT, LOCAL_TYPE }) => {\n  const qualifier = `${!['City', 'Postcode'].includes(LOCAL_TYPE) ? POSTCODE_DISTRICT + ', ' : ''}${LOCAL_TYPE !== 'City' ? (COUNTY_UNITARY || DISTRICT_BOROUGH) : ''}`\n  const text = `${NAME1}${qualifier ? ', ' + qualifier : ''}`\n\n  return {\n    id: ID,\n    text: `${NAME1}${qualifier ? ', ' + qualifier : ''}`,\n    marked: markString(text, query)\n  }\n}\n\nconst parseResults = async (query, transformGeocodeRequest) => {\n  if (!query) {\n    return []\n  }\n  let url = config.URL\n  url = url.replace('{query}', encodeURI(query)).replace('{maxresults}', isPostcode(query) ? 1 : 100)\n  let results = []\n  try {\n    const response = await fetch(await transformGeocodeRequest(url))\n    const json = await response.json()\n    if (json.error || json.header.totalresults === 0) {\n      return []\n    }\n    results = removeTenuousResults(json.results, query)\n    results = removeDuplicates(results)\n    results = removeNonEngland(results)\n    results = results.slice(0, 8)\n  } catch (err) {\n    console.log(err)\n  }\n  return results\n}\n\nclass Geocode {\n  constructor (transformGeocodeRequest = (u) => u) {\n    this.transformGeocodeRequest = transformGeocodeRequest\n  }\n\n  async suggest (query) {\n    if (!query) {\n      return []\n    }\n    const results = await parseResults(query, this.transformGeocodeRequest)\n    return results.map(l => suggestion(query, l.GAZETTEER_ENTRY))\n  }\n\n  async find (query) {\n    if (!query) {\n      return null\n    }\n    const results = await parseResults(query, this.transformGeocodeRequest)\n    return results.length ? place(results[0].GAZETTEER_ENTRY) : null\n  }\n}\n\nexport default Geocode\n","/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/* Geodesy representation conversion functions                        (c) Chris Veness 2002-2020  */\n/*                                                                                   MIT Licence  */\n/* www.movable-type.co.uk/scripts/latlong.html                                                    */\n/* www.movable-type.co.uk/scripts/js/geodesy/geodesy-library.html#dms                             */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n/* eslint no-irregular-whitespace: [2, { skipComments: true }] */\n\n\n/**\n * Latitude/longitude points may be represented as decimal degrees, or subdivided into sexagesimal\n * minutes and seconds. This module provides methods for parsing and representing degrees / minutes\n * / seconds.\n *\n * @module dms\n */\n\n\n/* Degree-minutes-seconds (& cardinal directions) separator character */\nlet dmsSeparator = '\\u202f'; // U+202F = 'narrow no-break space'\n\n\n/**\n * Functions for parsing and representing degrees / minutes / seconds.\n */\nclass Dms {\n\n    // note Unicode Degree = U+00B0. Prime = U+2032, Double prime = U+2033\n\n    /**\n     * Separator character to be used to separate degrees, minutes, seconds, and cardinal directions.\n     *\n     * Default separator is U+202F narrow no-break space.\n     *\n     * To change this (e.g. to empty string or full space), set Dms.separator prior to invoking\n     * formatting.\n     *\n     * @example\n     *   import LatLon, { Dms } from '/js/geodesy/latlon-spherical.js';\n     *   const p = new LatLon(51.2, 0.33).toString('dms');  // 511200N, 0001948E\n     *   Dms.separator = '';                                // no separator\n     *   const p = new LatLon(51.2, 0.33).toString('dms'); // 511200N, 0001948E\n     */\n    static get separator()     { return dmsSeparator; }\n    static set separator(char) { dmsSeparator = char; }\n\n\n    /**\n     * Parses string representing degrees/minutes/seconds into numeric degrees.\n     *\n     * This is very flexible on formats, allowing signed decimal degrees, or deg-min-sec optionally\n     * suffixed by compass direction (NSEW); a variety of separators are accepted. Examples -3.62,\n     * '3 37 12W', '33712W'.\n     *\n     * Thousands/decimal separators must be comma/dot; use Dms.fromLocale to convert locale-specific\n     * thousands/decimal separators.\n     *\n     * @param   {string|number} dms - Degrees or deg/min/sec in variety of formats.\n     * @returns {number}        Degrees as decimal number.\n     *\n     * @example\n     *   const lat = Dms.parse('51 28 40.37 N');\n     *   const lon = Dms.parse('000 00 05.29 W');\n     *   const p1 = new LatLon(lat, lon); // 51.4779N, 000.0015W\n     */\n    static parse(dms) {\n        // check for signed decimal degrees without NSEW, if so return it directly\n        if (!isNaN(parseFloat(dms)) && isFinite(dms)) return Number(dms);\n\n        // strip off any sign or compass dir'n & split out separate d/m/s\n        const dmsParts = String(dms).trim().replace(/^-/, '').replace(/[NSEW]$/i, '').split(/[^0-9.,]+/);\n        if (dmsParts[dmsParts.length-1]=='') dmsParts.splice(dmsParts.length-1);  // from trailing symbol\n\n        if (dmsParts == '') return NaN;\n\n        // and convert to decimal degrees...\n        let deg = null;\n        switch (dmsParts.length) {\n            case 3:  // interpret 3-part result as d/m/s\n                deg = dmsParts[0]/1 + dmsParts[1]/60 + dmsParts[2]/3600;\n                break;\n            case 2:  // interpret 2-part result as d/m\n                deg = dmsParts[0]/1 + dmsParts[1]/60;\n                break;\n            case 1:  // just d (possibly decimal) or non-separated dddmmss\n                deg = dmsParts[0];\n                // check for fixed-width unseparated format eg 0033709W\n                //if (/[NS]/i.test(dmsParts)) deg = '0' + deg;  // - normalise N/S to 3-digit degrees\n                //if (/[0-9]{7}/.test(deg)) deg = deg.slice(0,3)/1 + deg.slice(3,5)/60 + deg.slice(5)/3600;\n                break;\n            default:\n                return NaN;\n        }\n        if (/^-|[WS]$/i.test(dms.trim())) deg = -deg; // take '-', west and south as -ve\n\n        return Number(deg);\n    }\n\n\n    /**\n     * Converts decimal degrees to deg/min/sec format\n     *  - degree, prime, double-prime symbols are added, but sign is discarded, though no compass\n     *    direction is added.\n     *  - degrees are zero-padded to 3 digits; for degrees latitude, use .slice(1) to remove leading\n     *    zero.\n     *\n     * @private\n     * @param   {number} deg - Degrees to be formatted as specified.\n     * @param   {string} [format=d] - Return value as 'd', 'dm', 'dms' for deg, deg+min, deg+min+sec.\n     * @param   {number} [dp=4|2|0] - Number of decimal places to use  default 4 for d, 2 for dm, 0 for dms.\n     * @returns {string} Degrees formatted as deg/min/secs according to specified format.\n     */\n    static toDms(deg, format='d', dp=undefined) {\n        if (isNaN(deg)) return null;  // give up here if we can't make a number from deg\n        if (typeof deg == 'string' && deg.trim() == '') return null;\n        if (typeof deg == 'boolean') return null;\n        if (deg == Infinity) return null;\n        if (deg == null) return null;\n\n        // default values\n        if (dp === undefined) {\n            switch (format) {\n                case 'd':   case 'deg':         dp = 4; break;\n                case 'dm':  case 'deg+min':     dp = 2; break;\n                case 'dms': case 'deg+min+sec': dp = 0; break;\n                default:          format = 'd'; dp = 4; break; // be forgiving on invalid format\n            }\n        }\n\n        deg = Math.abs(deg);  // (unsigned result ready for appending compass dir'n)\n\n        let dms = null, d = null, m = null, s = null;\n        switch (format) {\n            default: // invalid format spec!\n            case 'd': case 'deg':\n                d = deg.toFixed(dp);                       // round/right-pad degrees\n                if (d<100) d = '0' + d;                    // left-pad with leading zeros (note may include decimals)\n                if (d<10) d = '0' + d;\n                dms = d + '';\n                break;\n            case 'dm': case 'deg+min':\n                d = Math.floor(deg);                       // get component deg\n                m = ((deg*60) % 60).toFixed(dp);           // get component min & round/right-pad\n                if (m == 60) { m = (0).toFixed(dp); d++; } // check for rounding up\n                d = ('000'+d).slice(-3);                   // left-pad with leading zeros\n                if (m<10) m = '0' + m;                     // left-pad with leading zeros (note may include decimals)\n                dms = d + ''+Dms.separator + m + '';\n                break;\n            case 'dms': case 'deg+min+sec':\n                d = Math.floor(deg);                       // get component deg\n                m = Math.floor((deg*3600)/60) % 60;        // get component min\n                s = (deg*3600 % 60).toFixed(dp);           // get component sec & round/right-pad\n                if (s == 60) { s = (0).toFixed(dp); m++; } // check for rounding up\n                if (m == 60) { m = 0; d++; }               // check for rounding up\n                d = ('000'+d).slice(-3);                   // left-pad with leading zeros\n                m = ('00'+m).slice(-2);                    // left-pad with leading zeros\n                if (s<10) s = '0' + s;                     // left-pad with leading zeros (note may include decimals)\n                dms = d + ''+Dms.separator + m + ''+Dms.separator + s + '';\n                break;\n        }\n\n        return dms;\n    }\n\n\n    /**\n     * Converts numeric degrees to deg/min/sec latitude (2-digit degrees, suffixed with N/S).\n     *\n     * @param   {number} deg - Degrees to be formatted as specified.\n     * @param   {string} [format=d] - Return value as 'd', 'dm', 'dms' for deg, deg+min, deg+min+sec.\n     * @param   {number} [dp=4|2|0] - Number of decimal places to use  default 4 for d, 2 for dm, 0 for dms.\n     * @returns {string} Degrees formatted as deg/min/secs according to specified format.\n     *\n     * @example\n     *   const lat = Dms.toLat(-3.62, 'dms'); // 33712S\n     */\n    static toLat(deg, format, dp) {\n        const lat = Dms.toDms(Dms.wrap90(deg), format, dp);\n        return lat===null ? '' : lat.slice(1) + Dms.separator + (deg<0 ? 'S' : 'N');  // knock off initial '0' for lat!\n    }\n\n\n    /**\n     * Convert numeric degrees to deg/min/sec longitude (3-digit degrees, suffixed with E/W).\n     *\n     * @param   {number} deg - Degrees to be formatted as specified.\n     * @param   {string} [format=d] - Return value as 'd', 'dm', 'dms' for deg, deg+min, deg+min+sec.\n     * @param   {number} [dp=4|2|0] - Number of decimal places to use  default 4 for d, 2 for dm, 0 for dms.\n     * @returns {string} Degrees formatted as deg/min/secs according to specified format.\n     *\n     * @example\n     *   const lon = Dms.toLon(-3.62, 'dms'); // 33712W\n     */\n    static toLon(deg, format, dp) {\n        const lon = Dms.toDms(Dms.wrap180(deg), format, dp);\n        return lon===null ? '' : lon + Dms.separator + (deg<0 ? 'W' : 'E');\n    }\n\n\n    /**\n     * Converts numeric degrees to deg/min/sec as a bearing (0..360).\n     *\n     * @param   {number} deg - Degrees to be formatted as specified.\n     * @param   {string} [format=d] - Return value as 'd', 'dm', 'dms' for deg, deg+min, deg+min+sec.\n     * @param   {number} [dp=4|2|0] - Number of decimal places to use  default 4 for d, 2 for dm, 0 for dms.\n     * @returns {string} Degrees formatted as deg/min/secs according to specified format.\n     *\n     * @example\n     *   const lon = Dms.toBrng(-3.62, 'dms'); // 3562248\n     */\n    static toBrng(deg, format, dp) {\n        const brng =  Dms.toDms(Dms.wrap360(deg), format, dp);\n        return brng===null ? '' : brng.replace('360', '0');  // just in case rounding took us up to 360!\n    }\n\n\n    /**\n     * Converts DMS string from locale thousands/decimal separators to JavaScript comma/dot separators\n     * for subsequent parsing.\n     *\n     * Both thousands and decimal separators must be followed by a numeric character, to facilitate\n     * parsing of single lat/long string (in which whitespace must be left after the comma separator).\n     *\n     * @param   {string} str - Degrees/minutes/seconds formatted with locale separators.\n     * @returns {string} Degrees/minutes/seconds formatted with standard Javascript separators.\n     *\n     * @example\n     *   const lat = Dms.fromLocale('512840,12N');                          // '512840.12N' in France\n     *   const p = new LatLon(Dms.fromLocale('512840,37N, 0000005,29W'); // '51.4779N, 000.0015W' in France\n     */\n    static fromLocale(str) {\n        const locale = (123456.789).toLocaleString();\n        const separator = { thousands: locale.slice(3, 4), decimal: locale.slice(7, 8) };\n        return str.replace(separator.thousands, '').replace(separator.decimal, '.').replace('', ',');\n    }\n\n\n    /**\n     * Converts DMS string from JavaScript comma/dot thousands/decimal separators to locale separators.\n     *\n     * Can also be used to format standard numbers such as distances.\n     *\n     * @param   {string} str - Degrees/minutes/seconds formatted with standard Javascript separators.\n     * @returns {string} Degrees/minutes/seconds formatted with locale separators.\n     *\n     * @example\n     *   const Dms.toLocale('123,456.789');                   // '123.456,789' in France\n     *   const Dms.toLocale('512840.12N, 0000005.31W'); // '512840,12N, 0000005,31W' in France\n     */\n    static toLocale(str) {\n        const locale = (123456.789).toLocaleString();\n        const separator = { thousands: locale.slice(3, 4), decimal: locale.slice(7, 8) };\n        return str.replace(/,([0-9])/, '$1').replace('.', separator.decimal).replace('', separator.thousands);\n    }\n\n\n    /**\n     * Returns compass point (to given precision) for supplied bearing.\n     *\n     * @param   {number} bearing - Bearing in degrees from north.\n     * @param   {number} [precision=3] - Precision (1:cardinal / 2:intercardinal / 3:secondary-intercardinal).\n     * @returns {string} Compass point for supplied bearing.\n     *\n     * @example\n     *   const point = Dms.compassPoint(24);    // point = 'NNE'\n     *   const point = Dms.compassPoint(24, 1); // point = 'N'\n     */\n    static compassPoint(bearing, precision=3) {\n        if (![ 1, 2, 3 ].includes(Number(precision))) throw new RangeError(`invalid precision ${precision}`);\n        // note precision could be extended to 4 for quarter-winds (eg NbNW), but I think they are little used\n\n        bearing = Dms.wrap360(bearing); // normalise to range 0..360\n\n        const cardinals = [\n            'N', 'NNE', 'NE', 'ENE',\n            'E', 'ESE', 'SE', 'SSE',\n            'S', 'SSW', 'SW', 'WSW',\n            'W', 'WNW', 'NW', 'NNW' ];\n        const n = 4 * 2**(precision-1); // no of compass points at reqd precision (1=>4, 2=>8, 3=>16)\n        const cardinal = cardinals[Math.round(bearing*n/360)%n * 16/n];\n\n        return cardinal;\n    }\n\n\n    /**\n     * Constrain degrees to range -90..+90 (for latitude); e.g. -91 => -89, 91 => 89.\n     *\n     * @private\n     * @param {number} degrees\n     * @returns degrees within range -90..+90.\n     */\n    static wrap90(degrees) {\n        if (-90<=degrees && degrees<=90) return degrees; // avoid rounding due to arithmetic ops if within range\n\n        // latitude wrapping requires a triangle wave function; a general triangle wave is\n        //     f(x) = 4a/p  | (x-p/4)%p - p/2 | - a\n        // where a = amplitude, p = period, % = modulo; however, JavaScript '%' is a remainder operator\n        // not a modulo operator - for modulo, replace 'x%n' with '((x%n)+n)%n'\n        const x = degrees, a = 90, p = 360;\n        return 4*a/p * Math.abs((((x-p/4)%p)+p)%p - p/2) - a;\n    }\n\n    /**\n     * Constrain degrees to range -180..+180 (for longitude); e.g. -181 => 179, 181 => -179.\n     *\n     * @private\n     * @param {number} degrees\n     * @returns degrees within range -180..+180.\n     */\n    static wrap180(degrees) {\n        if (-180<=degrees && degrees<=180) return degrees; // avoid rounding due to arithmetic ops if within range\n\n        // longitude wrapping requires a sawtooth wave function; a general sawtooth wave is\n        //     f(x) = (2ax/p - p/2) % p - a\n        // where a = amplitude, p = period, % = modulo; however, JavaScript '%' is a remainder operator\n        // not a modulo operator - for modulo, replace 'x%n' with '((x%n)+n)%n'\n        const x = degrees, a = 180, p = 360;\n        return (((2*a*x/p - p/2)%p)+p)%p - a;\n    }\n\n    /**\n     * Constrain degrees to range 0..360 (for bearings); e.g. -1 => 359, 361 => 1.\n     *\n     * @private\n     * @param {number} degrees\n     * @returns degrees within range 0..360.\n     */\n    static wrap360(degrees) {\n        if (0<=degrees && degrees<360) return degrees; // avoid rounding due to arithmetic ops if within range\n\n        // bearing wrapping requires a sawtooth wave function with a vertical offset equal to the\n        // amplitude and a corresponding phase shift; this changes the general sawtooth wave function from\n        //     f(x) = (2ax/p - p/2) % p - a\n        // to\n        //     f(x) = (2ax/p) % p\n        // where a = amplitude, p = period, % = modulo; however, JavaScript '%' is a remainder operator\n        // not a modulo operator - for modulo, replace 'x%n' with '((x%n)+n)%n'\n        const x = degrees, a = 180, p = 360;\n        return (((2*a*x/p)%p)+p)%p;\n    }\n\n}\n\n\n// Extend Number object with methods to convert between degrees & radians\nNumber.prototype.toRadians = function() { return this * Math.PI / 180; };\nNumber.prototype.toDegrees = function() { return this * 180 / Math.PI; };\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nexport default Dms;\n","/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/* Vector handling functions                                          (c) Chris Veness 2011-2019  */\n/*                                                                                   MIT Licence  */\n/* www.movable-type.co.uk/scripts/geodesy-library.html#vector3d                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n\n/**\n * Library of 3-d vector manipulation routines.\n *\n * @module vector3d\n */\n\n\n/* Vector3d - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n\n/**\n * Functions for manipulating generic 3-d vectors.\n *\n * Functions return vectors as return results, so that operations can be chained.\n *\n * @example\n *   const v = v1.cross(v2).dot(v3) //  v1v2v3\n */\nclass Vector3d {\n\n    /**\n     * Creates a 3-d vector.\n     *\n     * @param {number} x - X component of vector.\n     * @param {number} y - Y component of vector.\n     * @param {number} z - Z component of vector.\n     *\n     * @example\n     *   import Vector3d from '/js/geodesy/vector3d.js';\n     *   const v = new Vector3d(0.267, 0.535, 0.802);\n     */\n    constructor(x, y, z) {\n        if (isNaN(x) || isNaN(y) || isNaN(z)) throw new TypeError(`invalid vector [${x},${y},${z}]`);\n\n        this.x = Number(x);\n        this.y = Number(y);\n        this.z = Number(z);\n    }\n\n\n    /**\n     * Length (magnitude or norm) of this vector.\n     *\n     * @returns {number} Magnitude of this vector.\n     */\n    get length() {\n        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n    }\n\n\n    /**\n     * Adds supplied vector to this vector.\n     *\n     * @param   {Vector3d} v - Vector to be added to this vector.\n     * @returns {Vector3d} Vector representing sum of this and v.\n     */\n    plus(v) {\n        if (!(v instanceof Vector3d)) throw new TypeError('v is not Vector3d object');\n\n        return new Vector3d(this.x + v.x, this.y + v.y, this.z + v.z);\n    }\n\n\n    /**\n     * Subtracts supplied vector from this vector.\n     *\n     * @param   {Vector3d} v - Vector to be subtracted from this vector.\n     * @returns {Vector3d} Vector representing difference between this and v.\n     */\n    minus(v) {\n        if (!(v instanceof Vector3d)) throw new TypeError('v is not Vector3d object');\n\n        return new Vector3d(this.x - v.x, this.y - v.y, this.z - v.z);\n    }\n\n\n    /**\n     * Multiplies this vector by a scalar value.\n     *\n     * @param   {number}   x - Factor to multiply this vector by.\n     * @returns {Vector3d} Vector scaled by x.\n     */\n    times(x) {\n        if (isNaN(x)) throw new TypeError(`invalid scalar value ${x}`);\n\n        return new Vector3d(this.x * x, this.y * x, this.z * x);\n    }\n\n\n    /**\n     * Divides this vector by a scalar value.\n     *\n     * @param   {number}   x - Factor to divide this vector by.\n     * @returns {Vector3d} Vector divided by x.\n     */\n    dividedBy(x) {\n        if (isNaN(x)) throw new TypeError(`invalid scalar value ${x}`);\n\n        return new Vector3d(this.x / x, this.y / x, this.z / x);\n    }\n\n\n    /**\n     * Multiplies this vector by the supplied vector using dot (scalar) product.\n     *\n     * @param   {Vector3d} v - Vector to be dotted with this vector.\n     * @returns {number}   Dot product of this and v.\n     */\n    dot(v) {\n        if (!(v instanceof Vector3d)) throw new TypeError('v is not Vector3d object');\n\n        return this.x * v.x + this.y * v.y + this.z * v.z;\n    }\n\n\n    /**\n     * Multiplies this vector by the supplied vector using cross (vector) product.\n     *\n     * @param   {Vector3d} v - Vector to be crossed with this vector.\n     * @returns {Vector3d} Cross product of this and v.\n     */\n    cross(v) {\n        if (!(v instanceof Vector3d)) throw new TypeError('v is not Vector3d object');\n\n        const x = this.y * v.z - this.z * v.y;\n        const y = this.z * v.x - this.x * v.z;\n        const z = this.x * v.y - this.y * v.x;\n\n        return new Vector3d(x, y, z);\n    }\n\n\n    /**\n     * Negates a vector to point in the opposite direction.\n     *\n     * @returns {Vector3d} Negated vector.\n     */\n    negate() {\n        return new Vector3d(-this.x, -this.y, -this.z);\n    }\n\n\n    /**\n     * Normalizes a vector to its unit vector\n     *  if the vector is already unit or is zero magnitude, this is a no-op.\n     *\n     * @returns {Vector3d} Normalised version of this vector.\n     */\n    unit() {\n        const norm = this.length;\n        if (norm == 1) return this;\n        if (norm == 0) return this;\n\n        const x = this.x / norm;\n        const y = this.y / norm;\n        const z = this.z / norm;\n\n        return new Vector3d(x, y, z);\n    }\n\n\n    /**\n     * Calculates the angle between this vector and supplied vector atan2(|pp|, pp) (or if\n     * (extra-planar) n supplied then atan2(npp, pp).\n     *\n     * @param   {Vector3d} v - Vector whose angle is to be determined from this vector.\n     * @param   {Vector3d} [n] - Plane normal: if supplied, angle is signed +ve if this->v is\n     *                     clockwise looking along n, -ve in opposite direction.\n     * @returns {number}   Angle (in radians) between this vector and supplied vector (in range 0..\n     *                     if n not supplied, range -..+ if n supplied).\n     */\n    angleTo(v, n=undefined) {\n        if (!(v instanceof Vector3d)) throw new TypeError('v is not Vector3d object');\n        if (!(n instanceof Vector3d || n == undefined)) throw new TypeError('n is not Vector3d object');\n\n        // q.v. stackoverflow.com/questions/14066933#answer-16544330, but npp is numerically\n        // ill-conditioned, so just calculate sign to apply to |pp|\n\n        // if npp is -ve, negate |pp|\n        const sign = n==undefined || this.cross(v).dot(n)>=0 ? 1 : -1;\n\n        const sin = this.cross(v).length * sign;\n        const cos = this.dot(v);\n\n        return Math.atan2(sin, cos);\n    }\n\n\n    /**\n     * Rotates this point around an axis by a specified angle.\n     *\n     * @param   {Vector3d} axis - The axis being rotated around.\n     * @param   {number}   angle - The angle of rotation (in degrees).\n     * @returns {Vector3d} The rotated point.\n     */\n    rotateAround(axis, angle) {\n        if (!(axis instanceof Vector3d)) throw new TypeError('axis is not Vector3d object');\n\n        const  = angle.toRadians();\n\n        // en.wikipedia.org/wiki/Rotation_matrix#Rotation_matrix_from_axis_and_angle\n        // en.wikipedia.org/wiki/Quaternions_and_spatial_rotation#Quaternion-derived_rotation_matrix\n        const p = this.unit();\n        const a = axis.unit();\n\n        const s = Math.sin();\n        const c = Math.cos();\n        const t = 1-c;\n        const x = a.x, y = a.y, z = a.z;\n\n        const r = [ // rotation matrix for rotation about supplied axis\n            [ t*x*x + c,   t*x*y - s*z, t*x*z + s*y ],\n            [ t*x*y + s*z, t*y*y + c,   t*y*z - s*x ],\n            [ t*x*z - s*y, t*y*z + s*x, t*z*z + c   ],\n        ];\n\n        // multiply r  p\n        const rp = [\n            r[0][0]*p.x + r[0][1]*p.y + r[0][2]*p.z,\n            r[1][0]*p.x + r[1][1]*p.y + r[1][2]*p.z,\n            r[2][0]*p.x + r[2][1]*p.y + r[2][2]*p.z,\n        ];\n        const p2 = new Vector3d(rp[0], rp[1], rp[2]);\n\n        return p2;\n        // qv en.wikipedia.org/wiki/Rodrigues'_rotation_formula...\n    }\n\n\n    /**\n     * String representation of vector.\n     *\n     * @param   {number} [dp=3] - Number of decimal places to be used.\n     * @returns {string} Vector represented as [x,y,z].\n     */\n    toString(dp=3) {\n        return `[${this.x.toFixed(dp)},${this.y.toFixed(dp)},${this.z.toFixed(dp)}]`;\n    }\n\n}\n\n\n// Extend Number object with methods to convert between degrees & radians\nNumber.prototype.toRadians = function() { return this * Math.PI / 180; };\nNumber.prototype.toDegrees = function() { return this * 180 / Math.PI; };\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nexport default Vector3d;\n","/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/* Geodesy tools for an ellipsoidal earth model                       (c) Chris Veness 2005-2022  */\n/*                                                                                   MIT Licence  */\n/* Core class for latlon-ellipsoidal-datum & latlon-ellipsoidal-referenceframe.                   */\n/*                                                                                                */\n/* www.movable-type.co.uk/scripts/latlong-convert-coords.html                                     */\n/* www.movable-type.co.uk/scripts/geodesy-library.html#latlon-ellipsoidal                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nimport Dms      from './dms.js';\nimport Vector3d from './vector3d.js';\n\n\n/**\n * A latitude/longitude point defines a geographic location on or above/below the earths surface,\n * measured in degrees from the equator & the International Reference Meridian and in metres above\n * the ellipsoid, and based on a given datum.\n *\n * As so much modern geodesy is based on WGS-84 (as used by GPS), this module includes WGS-84\n * ellipsoid parameters, and it has methods for converting geodetic (latitude/longitude) points to/from\n * geocentric cartesian points; the latlon-ellipsoidal-datum and latlon-ellipsoidal-referenceframe\n * modules provide transformation parameters for converting between historical datums and between\n * modern reference frames.\n *\n * This module is used for both trigonometric geodesy (eg latlon-ellipsoidal-vincenty) and n-vector\n * geodesy (eg latlon-nvector-ellipsoidal), and also for UTM/MGRS mapping.\n *\n * @module latlon-ellipsoidal\n */\n\n\n/*\n * Ellipsoid parameters; exposed through static getter below.\n *\n * The only ellipsoid defined is WGS84, for use in utm/mgrs, vincenty, nvector.\n */\nconst ellipsoids = {\n    WGS84: { a: 6378137, b: 6356752.314245, f: 1/298.257223563 },\n};\n\n\n/*\n * Datums; exposed through static getter below.\n *\n * The only datum defined is WGS84, for use in utm/mgrs, vincenty, nvector.\n */\nconst datums = {\n    WGS84: { ellipsoid: ellipsoids.WGS84 },\n};\n\n\n// freeze static properties\nObject.freeze(ellipsoids.WGS84);\nObject.freeze(datums.WGS84);\n\n\n/* LatLonEllipsoidal - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n\n/**\n * Latitude/longitude points on an ellipsoidal model earth, with ellipsoid parameters and methods\n * for converting points to/from cartesian (ECEF) coordinates.\n *\n * This is the core class, which will usually be used via LatLonEllipsoidal_Datum or\n * LatLonEllipsoidal_ReferenceFrame.\n */\nclass LatLonEllipsoidal {\n\n    /**\n     * Creates a geodetic latitude/longitude point on a (WGS84) ellipsoidal model earth.\n     *\n     * @param  {number} lat - Latitude (in degrees).\n     * @param  {number} lon - Longitude (in degrees).\n     * @param  {number} [height=0] - Height above ellipsoid in metres.\n     * @throws {TypeError} Invalid lat/lon/height.\n     *\n     * @example\n     *   import LatLon from '/js/geodesy/latlon-ellipsoidal.js';\n     *   const p = new LatLon(51.47788, -0.00147, 17);\n     */\n    constructor(lat, lon, height=0) {\n        if (isNaN(lat) || lat == null) throw new TypeError(`invalid lat ${lat}`);\n        if (isNaN(lon) || lon == null) throw new TypeError(`invalid lon ${lon}`);\n        if (isNaN(height) || height == null) throw new TypeError(`invalid height ${height}`);\n\n        this._lat = Dms.wrap90(Number(lat));\n        this._lon = Dms.wrap180(Number(lon));\n        this._height = Number(height);\n    }\n\n\n    /**\n     * Latitude in degrees north from equator (including aliases lat, latitude): can be set as\n     * numeric or hexagesimal (deg-min-sec); returned as numeric.\n     */\n    get lat()       { return this._lat; }\n    get latitude()  { return this._lat; }\n    set lat(lat) {\n        this._lat = isNaN(lat) ? Dms.wrap90(Dms.parse(lat)) : Dms.wrap90(Number(lat));\n        if (isNaN(this._lat)) throw new TypeError(`invalid lat ${lat}`);\n    }\n    set latitude(lat) {\n        this._lat = isNaN(lat) ? Dms.wrap90(Dms.parse(lat)) : Dms.wrap90(Number(lat));\n        if (isNaN(this._lat)) throw new TypeError(`invalid latitude ${lat}`);\n    }\n\n    /**\n     * Longitude in degrees east from international reference meridian (including aliases lon, lng,\n     * longitude): can be set as numeric or hexagesimal (deg-min-sec); returned as numeric.\n     */\n    get lon()       { return this._lon; }\n    get lng()       { return this._lon; }\n    get longitude() { return this._lon; }\n    set lon(lon) {\n        this._lon = isNaN(lon) ? Dms.wrap180(Dms.parse(lon)) : Dms.wrap180(Number(lon));\n        if (isNaN(this._lon)) throw new TypeError(`invalid lon ${lon}`);\n    }\n    set lng(lon) {\n        this._lon = isNaN(lon) ? Dms.wrap180(Dms.parse(lon)) : Dms.wrap180(Number(lon));\n        if (isNaN(this._lon)) throw new TypeError(`invalid lng ${lon}`);\n    }\n    set longitude(lon) {\n        this._lon = isNaN(lon) ? Dms.wrap180(Dms.parse(lon)) : Dms.wrap180(Number(lon));\n        if (isNaN(this._lon)) throw new TypeError(`invalid longitude ${lon}`);\n    }\n\n    /**\n     * Height in metres above ellipsoid.\n     */\n    get height()       { return this._height; }\n    set height(height) { this._height = Number(height); if (isNaN(this._height)) throw new TypeError(`invalid height ${height}`); }\n\n\n    /**\n     * Datum.\n     *\n     * Note this is replicated within LatLonEllipsoidal in order that a LatLonEllipsoidal object can\n     * be monkey-patched to look like a LatLonEllipsoidal_Datum, for Vincenty calculations on\n     * different ellipsoids.\n     *\n     * @private\n     */\n    get datum()      { return this._datum; }\n    set datum(datum) { this._datum = datum; }\n\n\n    /**\n     * Ellipsoids with their parameters; this module only defines WGS84 parameters a = 6378137, b =\n     * 6356752.314245, f = 1/298.257223563.\n     *\n     * @example\n     *   const a = LatLon.ellipsoids.WGS84.a; // 6378137\n     */\n    static get ellipsoids() {\n        return ellipsoids;\n    }\n\n    /**\n     * Datums; this module only defines WGS84 datum, hence no datum transformations.\n     *\n     * @example\n     *   const a = LatLon.datums.WGS84.ellipsoid.a; // 6377563.396\n     */\n    static get datums() {\n        return datums;\n    }\n\n\n    /**\n     * Parses a latitude/longitude point from a variety of formats.\n     *\n     * Latitude & longitude (in degrees) can be supplied as two separate parameters, as a single\n     * comma-separated lat/lon string, or as a single object with { lat, lon } or GeoJSON properties.\n     *\n     * The latitude/longitude values may be numeric or strings; they may be signed decimal or\n     * deg-min-sec (hexagesimal) suffixed by compass direction (NSEW); a variety of separators are\n     * accepted. Examples -3.62, '3 37 12W', '33712W'.\n     *\n     * Thousands/decimal separators must be comma/dot; use Dms.fromLocale to convert locale-specific\n     * thousands/decimal separators.\n     *\n     * @param   {number|string|Object} lat|latlon - Latitude (in degrees), or comma-separated lat/lon, or lat/lon object.\n     * @param   {number}               [lon]      - Longitude (in degrees).\n     * @param   {number}               [height=0] - Height above ellipsoid in metres.\n     * @returns {LatLon} Latitude/longitude point on WGS84 ellipsoidal model earth.\n     * @throws  {TypeError} Invalid coordinate.\n     *\n     * @example\n     *   const p1 = LatLon.parse(51.47788, -0.00147);              // numeric pair\n     *   const p2 = LatLon.parse('512840N, 0000005W', 17);   // dms string + height\n     *   const p3 = LatLon.parse({ lat: 52.205, lon: 0.119 }, 17); // { lat, lon } object numeric + height\n     */\n    static parse(...args) {\n        if (args.length == 0) throw new TypeError('invalid (empty) point');\n\n        let lat=undefined, lon=undefined, height=undefined;\n\n        // single { lat, lon } object\n        if (typeof args[0]=='object' && (args.length==1 || !isNaN(parseFloat(args[1])))) {\n            const ll = args[0];\n            if (ll.type == 'Point' && Array.isArray(ll.coordinates)) { // GeoJSON\n                [ lon, lat, height ] = ll.coordinates;\n                height = height || 0;\n            } else { // regular { lat, lon } object\n                if (ll.latitude  != undefined) lat = ll.latitude;\n                if (ll.lat       != undefined) lat = ll.lat;\n                if (ll.longitude != undefined) lon = ll.longitude;\n                if (ll.lng       != undefined) lon = ll.lng;\n                if (ll.lon       != undefined) lon = ll.lon;\n                if (ll.height    != undefined) height = ll.height;\n                lat = Dms.wrap90(Dms.parse(lat));\n                lon = Dms.wrap180(Dms.parse(lon));\n            }\n            if (args[1] != undefined) height = args[1];\n            if (isNaN(lat) || isNaN(lon)) throw new TypeError(`invalid point ${JSON.stringify(args[0])}`);\n        }\n\n        // single comma-separated lat/lon\n        if (typeof args[0] == 'string' && args[0].split(',').length == 2) {\n            [ lat, lon ] = args[0].split(',');\n            lat = Dms.wrap90(Dms.parse(lat));\n            lon = Dms.wrap180(Dms.parse(lon));\n            height = args[1] || 0;\n            if (isNaN(lat) || isNaN(lon)) throw new TypeError(`invalid point ${args[0]}`);\n        }\n\n        // regular (lat, lon) arguments\n        if (lat==undefined && lon==undefined) {\n            [ lat, lon ] = args;\n            lat = Dms.wrap90(Dms.parse(lat));\n            lon = Dms.wrap180(Dms.parse(lon));\n            height = args[2] || 0;\n            if (isNaN(lat) || isNaN(lon)) throw new TypeError(`invalid point ${args.toString()}`);\n        }\n\n        return new this(lat, lon, height); // 'new this' as may return subclassed types\n    }\n\n\n    /**\n     * Converts this point from (geodetic) latitude/longitude coordinates to (geocentric)\n     * cartesian (x/y/z) coordinates.\n     *\n     * @returns {Cartesian} Cartesian point equivalent to lat/lon point, with x, y, z in metres from\n     *   earth centre.\n     */\n    toCartesian() {\n        // x = (+h)coscos, y = (+h)cossin, z = ((1-e)+h)sin\n        // where  = a/(1esinsin), e = (a-b)/a or (better conditioned) 2f-f\n        const ellipsoid = this.datum\n            ? this.datum.ellipsoid\n            : this.referenceFrame ? this.referenceFrame.ellipsoid : ellipsoids.WGS84;\n\n        const  = this.lat.toRadians();\n        const  = this.lon.toRadians();\n        const h = this.height;\n        const { a, f } = ellipsoid;\n\n        const sin = Math.sin(), cos = Math.cos();\n        const sin = Math.sin(), cos = Math.cos();\n\n        const eSq = 2*f - f*f;                      // 1st eccentricity squared  (a-b)/a\n        const  = a / Math.sqrt(1 - eSq*sin*sin); // radius of curvature in prime vertical\n\n        const x = (+h) * cos * cos;\n        const y = (+h) * cos * sin;\n        const z = (*(1-eSq)+h) * sin;\n\n        return new Cartesian(x, y, z);\n    }\n\n\n    /**\n     * Checks if another point is equal to this point.\n     *\n     * @param   {LatLon} point - Point to be compared against this point.\n     * @returns {bool} True if points have identical latitude, longitude, height, and datum/referenceFrame.\n     * @throws  {TypeError} Invalid point.\n     *\n     * @example\n     *   const p1 = new LatLon(52.205, 0.119);\n     *   const p2 = new LatLon(52.205, 0.119);\n     *   const equal = p1.equals(p2); // true\n     */\n    equals(point) {\n        if (!(point instanceof LatLonEllipsoidal)) throw new TypeError(`invalid point ${point}`);\n\n        if (Math.abs(this.lat - point.lat) > Number.EPSILON) return false;\n        if (Math.abs(this.lon - point.lon) > Number.EPSILON) return false;\n        if (Math.abs(this.height - point.height) > Number.EPSILON) return false;\n        if (this.datum != point.datum) return false;\n        if (this.referenceFrame != point.referenceFrame) return false;\n        if (this.epoch != point.epoch) return false;\n\n        return true;\n    }\n\n\n    /**\n     * Returns a string representation of this point, formatted as degrees, degrees+minutes, or\n     * degrees+minutes+seconds.\n     *\n     * @param   {string} [format=d] - Format point as 'd', 'dm', 'dms', or 'n' for signed numeric.\n     * @param   {number} [dp=4|2|0] - Number of decimal places to use: default 4 for d, 2 for dm, 0 for dms.\n     * @param   {number} [dpHeight=null] - Number of decimal places to use for height; default is no height display.\n     * @returns {string} Comma-separated formatted latitude/longitude.\n     * @throws  {RangeError} Invalid format.\n     *\n     * @example\n     *   const greenwich = new LatLon(51.47788, -0.00147, 46);\n     *   const d = greenwich.toString();                        // 51.4779N, 000.0015W\n     *   const dms = greenwich.toString('dms', 2);              // 512840N, 0000005W\n     *   const [lat, lon] = greenwich.toString('n').split(','); // 51.4779, -0.0015\n     *   const dmsh = greenwich.toString('dms', 0, 0);          // 512840N, 0000006W +46m\n     */\n    toString(format='d', dp=undefined, dpHeight=null) {\n        // note: explicitly set dp to undefined for passing through to toLat/toLon\n        if (![ 'd', 'dm', 'dms', 'n' ].includes(format)) throw new RangeError(`invalid format ${format}`);\n\n        const height = (this.height>=0 ? ' +' : ' ') + this.height.toFixed(dpHeight) + 'm';\n        if (format == 'n') { // signed numeric degrees\n            if (dp == undefined) dp = 4;\n            const lat = this.lat.toFixed(dp);\n            const lon = this.lon.toFixed(dp);\n            return `${lat}, ${lon}${dpHeight==null ? '' : height}`;\n        }\n\n        const lat = Dms.toLat(this.lat, format, dp);\n        const lon = Dms.toLon(this.lon, format, dp);\n\n        return `${lat}, ${lon}${dpHeight==null ? '' : height}`;\n    }\n\n}\n\n\n/* Cartesian  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n\n/**\n * ECEF (earth-centered earth-fixed) geocentric cartesian coordinates.\n *\n * @extends Vector3d\n */\nclass Cartesian extends Vector3d {\n\n    /**\n     * Creates cartesian coordinate representing ECEF (earth-centric earth-fixed) point.\n     *\n     * @param {number} x - X coordinate in metres (=> 0N,0E).\n     * @param {number} y - Y coordinate in metres (=> 0N,90E).\n     * @param {number} z - Z coordinate in metres (=> 90N).\n     *\n     * @example\n     *   import { Cartesian } from '/js/geodesy/latlon-ellipsoidal.js';\n     *   const coord = new Cartesian(3980581.210, -111.159, 4966824.522);\n     */\n    constructor(x, y, z) {\n        super(x, y, z); // arguably redundant constructor, but specifies units & axes\n    }\n\n\n    /**\n     * Converts this (geocentric) cartesian (x/y/z) coordinate to (geodetic) latitude/longitude\n     * point on specified ellipsoid.\n     *\n     * Uses Bowrings (1985) formulation for m precision in concise form; The accuracy of geodetic\n     * latitude and height equations, B R Bowring, Survey Review vol 28, 218, Oct 1985.\n     *\n     * @param   {LatLon.ellipsoids} [ellipsoid=WGS84] - Ellipsoid to use when converting point.\n     * @returns {LatLon} Latitude/longitude point defined by cartesian coordinates, on given ellipsoid.\n     * @throws  {TypeError} Invalid ellipsoid.\n     *\n     * @example\n     *   const c = new Cartesian(4027893.924, 307041.993, 4919474.294);\n     *   const p = c.toLatLon(); // 50.7978N, 004.3592E\n     */\n    toLatLon(ellipsoid=ellipsoids.WGS84) {\n        // note ellipsoid is available as a parameter for when toLatLon gets subclassed to\n        // Ellipsoidal_Datum / Ellipsoidal_Referenceframe.\n        if (!ellipsoid || !ellipsoid.a) throw new TypeError(`invalid ellipsoid ${ellipsoid}`);\n\n        const { x, y, z } = this;\n        const { a, b, f } = ellipsoid;\n\n        const e2 = 2*f - f*f;           // 1st eccentricity squared  (ab)/a\n        const 2 = e2 / (1-e2);         // 2nd eccentricity squared  (ab)/b\n        const p = Math.sqrt(x*x + y*y); // distance from minor axis\n        const R = Math.sqrt(p*p + z*z); // polar radius\n\n        // parametric latitude (Bowring eqn.17, replacing tan = za / pb)\n        const tan = (b*z)/(a*p) * (1+2*b/R);\n        const sin = tan / Math.sqrt(1+tan*tan);\n        const cos = sin / tan;\n\n        // geodetic latitude (Bowring eqn.18: tan = z+bsin / pecos)\n        const  = isNaN(cos) ? 0 : Math.atan2(z + 2*b*sin*sin*sin, p - e2*a*cos*cos*cos);\n\n        // longitude\n        const  = Math.atan2(y, x);\n\n        // height above ellipsoid (Bowring eqn.7)\n        const sin = Math.sin(), cos = Math.cos();\n        const  = a / Math.sqrt(1-e2*sin*sin); // length of the normal terminated by the minor axis\n        const h = p*cos + z*sin - (a*a/);\n\n        const point = new LatLonEllipsoidal(.toDegrees(), .toDegrees(), h);\n\n        return point;\n    }\n\n\n    /**\n     * Returns a string representation of this cartesian point.\n     *\n     * @param   {number} [dp=0] - Number of decimal places to use.\n     * @returns {string} Comma-separated latitude/longitude.\n     */\n    toString(dp=0) {\n        const x = this.x.toFixed(dp), y = this.y.toFixed(dp), z = this.z.toFixed(dp);\n        return `[${x},${y},${z}]`;\n    }\n\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nexport { LatLonEllipsoidal as default, Cartesian, Vector3d, Dms };\n","/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/* Geodesy tools for conversions between (historical) datums          (c) Chris Veness 2005-2019  */\n/*                                                                                   MIT Licence  */\n/* www.movable-type.co.uk/scripts/latlong-convert-coords.html                                     */\n/* www.movable-type.co.uk/scripts/geodesy-library.html#latlon-ellipsoidal-datum                  */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nimport LatLonEllipsoidal, { Cartesian, Dms } from './latlon-ellipsoidal.js';\n\n\n/**\n * Historical geodetic datums: a latitude/longitude point defines a geographic location on or\n * above/below the  earths surface, measured in degrees from the equator & the International\n * Reference Meridian and metres above the ellipsoid, and based on a given datum. The datum is\n * based on a reference ellipsoid and tied to geodetic survey reference points.\n *\n * Modern geodesy is generally based on the WGS84 datum (as used for instance by GPS systems), but\n * previously various reference ellipsoids and datum references were used.\n *\n * This module extends the core latlon-ellipsoidal module to include ellipsoid parameters and datum\n * transformation parameters, and methods for converting between different (generally historical)\n * datums.\n *\n * It can be used for UK Ordnance Survey mapping (OS National Grid References are still based on the\n * otherwise historical OSGB36 datum), as well as for historical purposes.\n *\n * q.v. Ordnance Survey A guide to coordinate systems in Great Britain Section 6,\n * www.ordnancesurvey.co.uk/docs/support/guide-coordinate-systems-great-britain.pdf, and also\n * www.ordnancesurvey.co.uk/blog/2014/12/2.\n *\n * @module latlon-ellipsoidal-datum\n */\n\n\n/*\n * Ellipsoid parameters; exposed through static getter below.\n */\nconst ellipsoids = {\n    WGS84:         { a: 6378137,     b: 6356752.314245, f: 1/298.257223563 },\n    Airy1830:      { a: 6377563.396, b: 6356256.909,    f: 1/299.3249646   },\n    AiryModified:  { a: 6377340.189, b: 6356034.448,    f: 1/299.3249646   },\n    Bessel1841:    { a: 6377397.155, b: 6356078.962818, f: 1/299.1528128   },\n    Clarke1866:    { a: 6378206.4,   b: 6356583.8,      f: 1/294.978698214 },\n    Clarke1880IGN: { a: 6378249.2,   b: 6356515.0,      f: 1/293.466021294 },\n    GRS80:         { a: 6378137,     b: 6356752.314140, f: 1/298.257222101 },\n    Intl1924:      { a: 6378388,     b: 6356911.946,    f: 1/297           }, // aka Hayford\n    WGS72:         { a: 6378135,     b: 6356750.5,      f: 1/298.26        },\n};\n\n\n/*\n * Datums; exposed through static getter below.\n */\nconst datums = {\n    // transforms: t in metres, s in ppm, r in arcseconds              tx       ty        tz       s        rx        ry        rz\n    ED50:       { ellipsoid: ellipsoids.Intl1924,      transform: [   89.5,    93.8,    123.1,    -1.2,     0.0,      0.0,      0.156    ] }, // epsg.io/1311\n    ETRS89:     { ellipsoid: ellipsoids.GRS80,         transform: [    0,       0,        0,       0,       0,        0,        0        ] }, // epsg.io/1149; @ 1-metre level\n    Irl1975:    { ellipsoid: ellipsoids.AiryModified,  transform: [ -482.530, 130.596, -564.557,  -8.150,   1.042,    0.214,    0.631    ] }, // epsg.io/1954\n    NAD27:      { ellipsoid: ellipsoids.Clarke1866,    transform: [    8,    -160,     -176,       0,       0,        0,        0        ] },\n    NAD83:      { ellipsoid: ellipsoids.GRS80,         transform: [    0.9956, -1.9103,  -0.5215, -0.00062, 0.025915, 0.009426, 0.011599 ] },\n    NTF:        { ellipsoid: ellipsoids.Clarke1880IGN, transform: [  168,      60,     -320,       0,       0,        0,        0        ] },\n    OSGB36:     { ellipsoid: ellipsoids.Airy1830,      transform: [ -446.448, 125.157, -542.060,  20.4894, -0.1502,  -0.2470,  -0.8421   ] }, // epsg.io/1314\n    Potsdam:    { ellipsoid: ellipsoids.Bessel1841,    transform: [ -582,    -105,     -414,      -8.3,     1.04,     0.35,    -3.08     ] },\n    TokyoJapan: { ellipsoid: ellipsoids.Bessel1841,    transform: [  148,    -507,     -685,       0,       0,        0,        0        ] },\n    WGS72:      { ellipsoid: ellipsoids.WGS72,         transform: [    0,       0,       -4.5,    -0.22,    0,        0,        0.554    ] },\n    WGS84:      { ellipsoid: ellipsoids.WGS84,         transform: [    0.0,     0.0,      0.0,     0.0,     0.0,      0.0,      0.0      ] },\n};\n/* sources:\n * - ED50:       www.gov.uk/guidance/oil-and-gas-petroleum-operations-notices#pon-4\n * - Irl1975:    www.osi.ie/wp-content/uploads/2015/05/transformations_booklet.pdf\n * - NAD27:      en.wikipedia.org/wiki/Helmert_transformation\n * - NAD83:      www.uvm.edu/giv/resources/WGS84_NAD83.pdf [strictly, WGS84(G1150) -> NAD83(CORS96) @ epoch 1997.0]\n *               (note NAD83(1986)  WGS84(Original); confluence.qps.nl/pages/viewpage.action?pageId=29855173)\n * - NTF:        Nouvelle Triangulation Francaise geodesie.ign.fr/contenu/fichiers/Changement_systeme_geodesique.pdf\n * - OSGB36:     www.ordnancesurvey.co.uk/docs/support/guide-coordinate-systems-great-britain.pdf\n * - Potsdam:    kartoweb.itc.nl/geometrics/Coordinate%20transformations/coordtrans.html\n * - TokyoJapan: www.geocachingtoolbox.com?page=datumEllipsoidDetails\n * - WGS72:      www.icao.int/safety/pbn/documentation/eurocontrol/eurocontrol wgs 84 implementation manual.pdf\n *\n * more transform parameters are available from earth-info.nga.mil/GandG/coordsys/datums/NATO_DT.pdf,\n * www.fieldenmaps.info/cconv/web/cconv_params.js\n */\n/* note:\n * - ETRS89 reference frames are coincident with WGS-84 at epoch 1989.0 (ie null transform) at the one metre level.\n */\n\n\n// freeze static properties\nObject.keys(ellipsoids).forEach(e => Object.freeze(ellipsoids[e]));\nObject.keys(datums).forEach(d => { Object.freeze(datums[d]); Object.freeze(datums[d].transform); });\n\n\n/* LatLon - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n\n/**\n * Latitude/longitude points on an ellipsoidal model earth, with ellipsoid parameters and methods\n * for converting between datums and to geocentric (ECEF) cartesian coordinates.\n *\n * @extends LatLonEllipsoidal\n */\nclass LatLonEllipsoidal_Datum extends LatLonEllipsoidal {\n\n    /**\n     * Creates a geodetic latitude/longitude point on an ellipsoidal model earth using given datum.\n     *\n     * @param {number} lat - Latitude (in degrees).\n     * @param {number} lon - Longitude (in degrees).\n     * @param {number} [height=0] - Height above ellipsoid in metres.\n     * @param {LatLon.datums} datum - Datum this point is defined within.\n     *\n     * @example\n     *   import LatLon from '/js/geodesy/latlon-ellipsoidal-datum.js';\n     *   const p = new LatLon(53.3444, -6.2577, 17, LatLon.datums.Irl1975);\n     */\n    constructor(lat, lon, height=0, datum=datums.WGS84) {\n        if (!datum || datum.ellipsoid==undefined) throw new TypeError(`unrecognised datum ${datum}`);\n\n        super(lat, lon, height);\n\n        this._datum = datum;\n    }\n\n\n    /**\n     * Datum this point is defined within.\n     */\n    get datum() {\n        return this._datum;\n    }\n\n\n    /**\n     * Ellipsoids with their parameters; semi-major axis (a), semi-minor axis (b), and flattening (f).\n     *\n     * Flattening f = (ab)/a; at least one of these parameters is derived from defining constants.\n     *\n     * @example\n     *   const a = LatLon.ellipsoids.Airy1830.a; // 6377563.396\n     */\n    static get ellipsoids() {\n        return ellipsoids;\n    }\n\n\n    /**\n     * Datums; with associated ellipsoid, and Helmert transform parameters to convert from WGS-84\n     * into given datum.\n     *\n     * Note that precision of various datums will vary, and WGS-84 (original) is not defined to be\n     * accurate to better than 1 metre. No transformation should be assumed to be accurate to\n     * better than a metre, for many datums somewhat less.\n     *\n     * This is a small sample of commoner datums from a large set of historical datums. I will add\n     * new datums on request.\n     *\n     * @example\n     *   const a = LatLon.datums.OSGB36.ellipsoid.a;                    // 6377563.396\n     *   const tx = LatLon.datums.OSGB36.transform;                     // [ tx, ty, tz, s, rx, ry, rz ]\n     *   const availableDatums = Object.keys(LatLon.datums).join(', '); // ED50, Irl1975, NAD27, ...\n     */\n    static get datums() {\n        return datums;\n    }\n\n\n    // note instance datum getter/setters are in LatLonEllipsoidal\n\n\n    /**\n     * Parses a latitude/longitude point from a variety of formats.\n     *\n     * Latitude & longitude (in degrees) can be supplied as two separate parameters, as a single\n     * comma-separated lat/lon string, or as a single object with { lat, lon } or GeoJSON properties.\n     *\n     * The latitude/longitude values may be numeric or strings; they may be signed decimal or\n     * deg-min-sec (hexagesimal) suffixed by compass direction (NSEW); a variety of separators are\n     * accepted. Examples -3.62, '3 37 12W', '33712W'.\n     *\n     * Thousands/decimal separators must be comma/dot; use Dms.fromLocale to convert locale-specific\n     * thousands/decimal separators.\n     *\n     * @param   {number|string|Object} lat|latlon - Geodetic Latitude (in degrees) or comma-separated lat/lon or lat/lon object.\n     * @param   {number}               [lon] - Longitude in degrees.\n     * @param   {number}               [height=0] - Height above ellipsoid in metres.\n     * @param   {LatLon.datums}        [datum=WGS84] - Datum this point is defined within.\n     * @returns {LatLon} Latitude/longitude point on ellipsoidal model earth using given datum.\n     * @throws  {TypeError} Unrecognised datum.\n     *\n     * @example\n     *   const p = LatLon.parse('51.47736, 0.0000', 0, LatLon.datums.OSGB36);\n     */\n    static parse(...args) {\n        let datum = datums.WGS84;\n\n        // if the last argument is a datum, use that, otherwise use default WGS-84\n        if (args.length==4 || (args.length==3 && typeof args[2] == 'object')) datum = args.pop();\n\n        if (!datum || datum.ellipsoid==undefined) throw new TypeError(`unrecognised datum ${datum}`);\n\n        const point = super.parse(...args);\n\n        point._datum = datum;\n\n        return point;\n    }\n\n\n    /**\n     * Converts this lat/lon coordinate to new coordinate system.\n     *\n     * @param   {LatLon.datums} toDatum - Datum this coordinate is to be converted to.\n     * @returns {LatLon} This point converted to new datum.\n     * @throws  {TypeError} Unrecognised datum.\n     *\n     * @example\n     *   const pWGS84 = new LatLon(51.47788, -0.00147, 0, LatLon.datums.WGS84);\n     *   const pOSGB = pWGS84.convertDatum(LatLon.datums.OSGB36); // 51.4773N, 000.0001E\n     */\n    convertDatum(toDatum) {\n        if (!toDatum || toDatum.ellipsoid==undefined) throw new TypeError(`unrecognised datum ${toDatum}`);\n\n        const oldCartesian = this.toCartesian();                 // convert geodetic to cartesian\n        const newCartesian = oldCartesian.convertDatum(toDatum); // convert datum\n        const newLatLon = newCartesian.toLatLon();               // convert cartesian back to geodetic\n\n        return newLatLon;\n    }\n\n\n    /**\n     * Converts this point from (geodetic) latitude/longitude coordinates to (geocentric) cartesian\n     * (x/y/z) coordinates, based on the same datum.\n     *\n     * Shadow of LatLonEllipsoidal.toCartesian(), returning Cartesian augmented with\n     * LatLonEllipsoidal_Datum methods/properties.\n     *\n     * @returns {Cartesian} Cartesian point equivalent to lat/lon point, with x, y, z in metres from\n     *   earth centre, augmented with reference frame conversion methods and properties.\n     */\n    toCartesian() {\n        const cartesian = super.toCartesian();\n        const cartesianDatum = new Cartesian_Datum(cartesian.x, cartesian.y, cartesian.z, this.datum);\n        return cartesianDatum;\n    }\n\n}\n\n\n/* Cartesian  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n\n/**\n * Augments Cartesian with datum the cooordinate is based on, and methods to convert between datums\n * (using Helmert 7-parameter transforms) and to convert cartesian to geodetic latitude/longitude\n * point.\n *\n * @extends Cartesian\n */\nclass Cartesian_Datum extends Cartesian {\n\n    /**\n     * Creates cartesian coordinate representing ECEF (earth-centric earth-fixed) point, on a given\n     * datum. The datum will identify the primary meridian (for the x-coordinate), and is also\n     * useful in transforming to/from geodetic (lat/lon) coordinates.\n     *\n     * @param  {number} x - X coordinate in metres (=> 0N,0E).\n     * @param  {number} y - Y coordinate in metres (=> 0N,90E).\n     * @param  {number} z - Z coordinate in metres (=> 90N).\n     * @param  {LatLon.datums} [datum] - Datum this coordinate is defined within.\n     * @throws {TypeError} Unrecognised datum.\n     *\n     * @example\n     *   import { Cartesian } from '/js/geodesy/latlon-ellipsoidal-datum.js';\n     *   const coord = new Cartesian(3980581.210, -111.159, 4966824.522);\n     */\n    constructor(x, y, z, datum=undefined) {\n        if (datum && datum.ellipsoid==undefined) throw new TypeError(`unrecognised datum ${datum}`);\n\n        super(x, y, z);\n\n        if (datum) this._datum = datum;\n    }\n\n\n    /**\n     * Datum this point is defined within.\n     */\n    get datum() {\n        return this._datum;\n    }\n    set datum(datum) {\n        if (!datum || datum.ellipsoid==undefined) throw new TypeError(`unrecognised datum ${datum}`);\n        this._datum = datum;\n    }\n\n\n    /**\n     * Converts this (geocentric) cartesian (x/y/z) coordinate to (geodetic) latitude/longitude\n     * point (based on the same datum, or WGS84 if unset).\n     *\n     * Shadow of Cartesian.toLatLon(), returning LatLon augmented with LatLonEllipsoidal_Datum\n     * methods convertDatum, toCartesian, etc.\n     *\n     * @returns {LatLon} Latitude/longitude point defined by cartesian coordinates.\n     * @throws  {TypeError} Unrecognised datum\n     *\n     * @example\n     *   const c = new Cartesian(4027893.924, 307041.993, 4919474.294);\n     *   const p = c.toLatLon(); // 50.7978N, 004.3592E\n     */\n    toLatLon(deprecatedDatum=undefined) {\n        if (deprecatedDatum) {\n            console.info('datum parameter to Cartesian_Datum.toLatLon is deprecated: set datum before calling toLatLon()');\n            this.datum = deprecatedDatum;\n        }\n        const datum = this.datum || datums.WGS84;\n        if (!datum || datum.ellipsoid==undefined) throw new TypeError(`unrecognised datum ${datum}`);\n\n        const latLon = super.toLatLon(datum.ellipsoid); // TODO: what if datum is not geocentric?\n        const point = new LatLonEllipsoidal_Datum(latLon.lat, latLon.lon, latLon.height, this.datum);\n        return point;\n    }\n\n\n    /**\n     * Converts this cartesian coordinate to new datum using Helmert 7-parameter transformation.\n     *\n     * @param   {LatLon.datums} toDatum - Datum this coordinate is to be converted to.\n     * @returns {Cartesian} This point converted to new datum.\n     * @throws  {Error} Undefined datum.\n     *\n     * @example\n     *   const c = new Cartesian(3980574.247, -102.127, 4966830.065, LatLon.datums.OSGB36);\n     *   c.convertDatum(LatLon.datums.Irl1975); // [??,??,??]\n     */\n    convertDatum(toDatum) {\n        // TODO: what if datum is not geocentric?\n        if (!toDatum || toDatum.ellipsoid == undefined) throw new TypeError(`unrecognised datum ${toDatum}`);\n        if (!this.datum) throw new TypeError('cartesian coordinate has no datum');\n\n        let oldCartesian = null;\n        let transform = null;\n\n        if (this.datum == undefined || this.datum == datums.WGS84) {\n            // converting from WGS 84\n            oldCartesian = this;\n            transform = toDatum.transform;\n        }\n        if (toDatum == datums.WGS84) {\n            // converting to WGS 84; use inverse transform\n            oldCartesian = this;\n            transform = this.datum.transform.map(p => -p);\n        }\n        if (transform == null) {\n            // neither this.datum nor toDatum are WGS84: convert this to WGS84 first\n            oldCartesian = this.convertDatum(datums.WGS84);\n            transform = toDatum.transform;\n        }\n\n        const newCartesian = oldCartesian.applyTransform(transform);\n        newCartesian.datum = toDatum;\n\n        return newCartesian;\n    }\n\n\n    /**\n     * Applies Helmert 7-parameter transformation to this coordinate using transform parameters t.\n     *\n     * This is used in converting datums (geodetic->cartesian, apply transform, cartesian->geodetic).\n     *\n     * @private\n     * @param   {number[]} t - Transformation to apply to this coordinate.\n     * @returns {Cartesian} Transformed point.\n     */\n    applyTransform(t)   {\n        // this point\n        const { x: x1, y: y1, z: z1 } = this;\n\n        // transform parameters\n        const tx = t[0];                    // x-shift in metres\n        const ty = t[1];                    // y-shift in metres\n        const tz = t[2];                    // z-shift in metres\n        const s  = t[3]/1e6 + 1;            // scale: normalise parts-per-million to (s+1)\n        const rx = (t[4]/3600).toRadians(); // x-rotation: normalise arcseconds to radians\n        const ry = (t[5]/3600).toRadians(); // y-rotation: normalise arcseconds to radians\n        const rz = (t[6]/3600).toRadians(); // z-rotation: normalise arcseconds to radians\n\n        // apply transform\n        const x2 = tx + x1*s  - y1*rz + z1*ry;\n        const y2 = ty + x1*rz + y1*s  - z1*rx;\n        const z2 = tz - x1*ry + y1*rx + z1*s;\n\n        return new Cartesian_Datum(x2, y2, z2);\n    }\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nexport { LatLonEllipsoidal_Datum as default, Cartesian_Datum as Cartesian, datums, Dms };\n","/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/* Ordnance Survey Grid Reference functions                           (c) Chris Veness 2005-2021  */\n/*                                                                                   MIT Licence  */\n/* www.movable-type.co.uk/scripts/latlong-gridref.html                                            */\n/* www.movable-type.co.uk/scripts/geodesy-library.html#osgridref                                  */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nimport LatLonEllipsoidal, { Dms } from './latlon-ellipsoidal-datum.js';\n\n\n/**\n * Ordnance Survey OSGB grid references provide geocoordinate references for UK mapping purposes.\n *\n * Formulation implemented here due to Thomas, Redfearn, etc is as published by OS, but is inferior\n * to Krger as used by e.g. Karney 2011.\n *\n * www.ordnancesurvey.co.uk/documents/resources/guide-coordinate-systems-great-britain.pdf.\n *\n * Note OSGB grid references cover Great Britain only; Ireland and the Channel Islands have their\n * own references.\n *\n * Note that these formulae are based on ellipsoidal calculations, and according to the OS are\n * accurate to about 45 metres  for greater accuracy, a geoid-based transformation (OSTN15) must\n * be used.\n */\n\n/*\n * Converted 2015 to work with WGS84 by default, OSGB36 as option;\n * www.ordnancesurvey.co.uk/blog/2014/12/confirmation-on-changes-to-latitude-and-longitude\n */\n\n\n/* OsGridRef  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n\nconst nationalGrid = {\n    trueOrigin:  { lat: 49, lon: -2 },                 // true origin of grid 49N,2W on OSGB36 datum\n    falseOrigin: { easting: -400e3, northing: 100e3 }, // easting & northing of false origin, metres from true origin\n    scaleFactor: 0.9996012717,                         // scale factor on central meridian\n    ellipsoid:   LatLonEllipsoidal.ellipsoids.Airy1830,\n};\n// note Irish National Grid uses t/o 5330N, 8W, f/o 200kmW, 250kmS, scale factor 1.000035, on Airy 1830 Modified ellipsoid\n\n\n/**\n * OS Grid References with methods to parse and convert them to latitude/longitude points.\n */\nclass OsGridRef {\n\n    /**\n     * Creates an OsGridRef object.\n     *\n     * @param {number} easting - Easting in metres from OS Grid false origin.\n     * @param {number} northing - Northing in metres from OS Grid false origin.\n     *\n     * @example\n     *   import OsGridRef from '/js/geodesy/osgridref.js';\n     *   const gridref = new OsGridRef(651409, 313177);\n     */\n    constructor(easting, northing) {\n        this.easting = Number(easting);\n        this.northing = Number(northing);\n\n        if (isNaN(easting)  || this.easting<0  || this.easting>700e3) throw new RangeError(`invalid easting ${easting}`);\n        if (isNaN(northing) || this.northing<0 || this.northing>1300e3) throw new RangeError(`invalid northing ${northing}`);\n    }\n\n\n    /**\n     * Converts this Ordnance Survey Grid Reference easting/northing coordinate to latitude/longitude\n     * (SW corner of grid square).\n     *\n     * While OS Grid References are based on OSGB-36, the Ordnance Survey have deprecated the use of\n     * OSGB-36 for latitude/longitude coordinates (in favour of WGS-84), hence this function returns\n     * WGS-84 by default, with OSGB-36 as an option. See www.ordnancesurvey.co.uk/blog/2014/12/2.\n     *\n     * Note formulation implemented here due to Thomas, Redfearn, etc is as published by OS, but is\n     * inferior to Krger as used by e.g. Karney 2011.\n     *\n     * @param   {LatLon.datum} [datum=WGS84] - Datum to convert grid reference into.\n     * @returns {LatLon}       Latitude/longitude of supplied grid reference.\n     *\n     * @example\n     *   const gridref = new OsGridRef(651409.903, 313177.270);\n     *   const pWgs84 = gridref.toLatLon();                    // 523928.723N, 0014257.787E\n     *   // to obtain (historical) OSGB36 lat/lon point:\n     *   const pOsgb = gridref.toLatLon(LatLon.datums.OSGB36); // 523927.253N, 0014304.518E\n     */\n    toLatLon(datum=LatLonEllipsoidal.datums.WGS84) {\n        const { easting: E, northing: N } = this;\n\n        const { a, b } = nationalGrid.ellipsoid;            // a = 6377563.396, b = 6356256.909\n        const 0 = nationalGrid.trueOrigin.lat.toRadians(); // latitude of true origin, 49N\n        const 0 = nationalGrid.trueOrigin.lon.toRadians(); // longitude of true origin, 2W\n        const E0 = -nationalGrid.falseOrigin.easting;       // easting of true origin, 400km\n        const N0 = -nationalGrid.falseOrigin.northing;      // northing of true origin, -100km\n        const F0 = nationalGrid.scaleFactor;                // 0.9996012717\n\n        const e2 = 1 - (b*b)/(a*a);                         // eccentricity squared\n        const n = (a-b)/(a+b), n2 = n*n, n3 = n*n*n;        // n, n, n\n\n        let =0, M=0;\n        do {\n             = (N-N0-M)/(a*F0) + ;\n\n            const Ma = (1 + n + (5/4)*n2 + (5/4)*n3) * (-0);\n            const Mb = (3*n + 3*n*n + (21/8)*n3) * Math.sin(-0) * Math.cos(+0);\n            const Mc = ((15/8)*n2 + (15/8)*n3) * Math.sin(2*(-0)) * Math.cos(2*(+0));\n            const Md = (35/24)*n3 * Math.sin(3*(-0)) * Math.cos(3*(+0));\n            M = b * F0 * (Ma - Mb + Mc - Md);                // meridional arc\n\n        } while (Math.abs(N-N0-M) >= 0.00001);  // ie until < 0.01mm\n\n        const cos = Math.cos(), sin = Math.sin();\n        const  = a*F0/Math.sqrt(1-e2*sin*sin);            // nu = transverse radius of curvature\n        const  = a*F0*(1-e2)/Math.pow(1-e2*sin*sin, 1.5); // rho = meridional radius of curvature\n        const 2 = /-1;                                    // eta = ?\n\n        const tan = Math.tan();\n        const tan2 = tan*tan, tan4 = tan2*tan2, tan6 = tan4*tan2;\n        const sec = 1/cos;\n        const 3 = **, 5 = 3**, 7 = 5**;\n        const VII = tan/(2**);\n        const VIII = tan/(24**3)*(5+3*tan2+2-9*tan2*2);\n        const IX = tan/(720**5)*(61+90*tan2+45*tan4);\n        const X = sec/;\n        const XI = sec/(6*3)*(/+2*tan2);\n        const XII = sec/(120*5)*(5+28*tan2+24*tan4);\n        const XIIA = sec/(5040*7)*(61+662*tan2+1320*tan4+720*tan6);\n\n        const dE = (E-E0), dE2 = dE*dE, dE3 = dE2*dE, dE4 = dE2*dE2, dE5 = dE3*dE2, dE6 = dE4*dE2, dE7 = dE5*dE2;\n         =  - VII*dE2 + VIII*dE4 - IX*dE6;\n        const  = 0 + X*dE - XI*dE3 + XII*dE5 - XIIA*dE7;\n\n        let point = new LatLon_OsGridRef(.toDegrees(), .toDegrees(), 0, LatLonEllipsoidal.datums.OSGB36);\n\n        if (datum != LatLonEllipsoidal.datums.OSGB36) {\n            // if point is required in datum other than OSGB36, convert it\n            point = point.convertDatum(datum);\n            // convertDatum() gives us a LatLon: convert to LatLon_OsGridRef which includes toOsGrid()\n            point = new LatLon_OsGridRef(point.lat, point.lon, point.height, point.datum);\n        }\n\n        return point;\n    }\n\n\n    /**\n     * Parses grid reference to OsGridRef object.\n     *\n     * Accepts standard grid references (eg 'SU 387 148'), with or without whitespace separators, from\n     * two-digit references up to 10-digit references (1m  1m square), or fully numeric comma-separated\n     * references in metres (eg '438700,114800').\n     *\n     * @param   {string}    gridref - Standard format OS Grid Reference.\n     * @returns {OsGridRef} Numeric version of grid reference in metres from false origin (SW corner of\n     *   supplied grid square).\n     * @throws  {Error}     Invalid grid reference.\n     *\n     * @example\n     *   const grid = OsGridRef.parse('TG 51409 13177'); // grid: { easting: 651409, northing: 313177 }\n     */\n    static parse(gridref) {\n        gridref = String(gridref).trim();\n\n        // check for fully numeric comma-separated gridref format\n        let match = gridref.match(/^(\\d+),\\s*(\\d+)$/);\n        if (match) return new OsGridRef(match[1], match[2]);\n\n        // validate format\n        match = gridref.match(/^[HNST][ABCDEFGHJKLMNOPQRSTUVWXYZ]\\s*[0-9]+\\s*[0-9]+$/i);\n        if (!match) throw new Error(`invalid grid reference ${gridref}`);\n\n        // get numeric values of letter references, mapping A->0, B->1, C->2, etc:\n        let l1 = gridref.toUpperCase().charCodeAt(0) - 'A'.charCodeAt(0); // 500km square\n        let l2 = gridref.toUpperCase().charCodeAt(1) - 'A'.charCodeAt(0); // 100km square\n        // shuffle down letters after 'I' since 'I' is not used in grid:\n        if (l1 > 7) l1--;\n        if (l2 > 7) l2--;\n\n        // convert grid letters into 100km-square indexes from false origin (grid square SV):\n        const e100km = ((l1 - 2) % 5) * 5 + (l2 % 5);\n        const n100km = (19 - Math.floor(l1 / 5) * 5) - Math.floor(l2 / 5);\n\n        // skip grid letters to get numeric (easting/northing) part of ref\n        let en = gridref.slice(2).trim().split(/\\s+/);\n        // if e/n not whitespace separated, split half way\n        if (en.length == 1) en = [ en[0].slice(0, en[0].length / 2), en[0].slice(en[0].length / 2) ];\n\n        // validation\n        if (en[0].length != en[1].length) throw new Error(`invalid grid reference ${gridref}`);\n\n        // standardise to 10-digit refs (metres)\n        en[0] = en[0].padEnd(5, '0');\n        en[1] = en[1].padEnd(5, '0');\n\n        const e = e100km + en[0];\n        const n = n100km + en[1];\n\n        return new OsGridRef(e, n);\n    }\n\n\n    /**\n     * Converts this numeric grid reference to standard OS Grid Reference.\n     *\n     * @param   {number} [digits=10] - Precision of returned grid reference (10 digits = metres);\n     *   digits=0 will return grid reference in numeric format.\n     * @returns {string} This grid reference in standard format.\n     *\n     * @example\n     *   const gridref = new OsGridRef(651409, 313177).toString(8); // 'TG 5140 1317'\n     *   const gridref = new OsGridRef(651409, 313177).toString(0); // '651409,313177'\n     */\n    toString(digits=10) {\n        if (![ 0,2,4,6,8,10,12,14,16 ].includes(Number(digits))) throw new RangeError(`invalid precision ${digits}`); // eslint-disable-line comma-spacing\n\n        let { easting: e, northing: n } = this;\n\n        // use digits = 0 to return numeric format (in metres) - note northing may be >= 1e7\n        if (digits == 0) {\n            const format = { useGrouping: false,  minimumIntegerDigits: 6, maximumFractionDigits: 3 };\n            const ePad = e.toLocaleString('en', format);\n            const nPad = n.toLocaleString('en', format);\n            return `${ePad},${nPad}`;\n        }\n\n        // get the 100km-grid indices\n        const e100km = Math.floor(e / 100000), n100km = Math.floor(n / 100000);\n\n        // translate those into numeric equivalents of the grid letters\n        let l1 = (19 - n100km) - (19 - n100km) % 5 + Math.floor((e100km + 10) / 5);\n        let l2 = (19 - n100km) * 5 % 25 + e100km % 5;\n\n        // compensate for skipped 'I' and build grid letter-pairs\n        if (l1 > 7) l1++;\n        if (l2 > 7) l2++;\n        const letterPair = String.fromCharCode(l1 + 'A'.charCodeAt(0), l2 + 'A'.charCodeAt(0));\n\n        // strip 100km-grid indices from easting & northing, and reduce precision\n        e = Math.floor((e % 100000) / Math.pow(10, 5 - digits / 2));\n        n = Math.floor((n % 100000) / Math.pow(10, 5 - digits / 2));\n\n        // pad eastings & northings with leading zeros\n        e = e.toString().padStart(digits/2, '0');\n        n = n.toString().padStart(digits/2, '0');\n\n        return `${letterPair} ${e} ${n}`;\n    }\n\n}\n\n\n/* LatLon_OsGridRef - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n\n/**\n * Extends LatLon class with method to convert LatLon point to OS Grid Reference.\n *\n * @extends LatLonEllipsoidal\n */\nclass LatLon_OsGridRef extends LatLonEllipsoidal {\n\n    /**\n     * Converts latitude/longitude to Ordnance Survey grid reference easting/northing coordinate.\n     *\n     * @returns {OsGridRef} OS Grid Reference easting/northing.\n     *\n     * @example\n     *   const grid = new LatLon(52.65798, 1.71605).toOsGrid(); // TG 51409 13177\n     *   // for conversion of (historical) OSGB36 latitude/longitude point:\n     *   const grid = new LatLon(52.65798, 1.71605).toOsGrid(LatLon.datums.OSGB36);\n     */\n    toOsGrid() {\n        // if necessary convert to OSGB36 first\n        const point = this.datum == LatLonEllipsoidal.datums.OSGB36\n            ? this\n            : this.convertDatum(LatLonEllipsoidal.datums.OSGB36);\n\n        const  = point.lat.toRadians();\n        const  = point.lon.toRadians();\n\n        const { a, b } = nationalGrid.ellipsoid;            // a = 6377563.396, b = 6356256.909\n        const 0 = nationalGrid.trueOrigin.lat.toRadians(); // latitude of true origin, 49N\n        const 0 = nationalGrid.trueOrigin.lon.toRadians(); // longitude of true origin, 2W\n        const E0 = -nationalGrid.falseOrigin.easting;       // easting of true origin, 400km\n        const N0 = -nationalGrid.falseOrigin.northing;      // northing of true origin, -100km\n        const F0 = nationalGrid.scaleFactor;                // 0.9996012717\n\n        const e2 = 1 - (b*b)/(a*a);                          // eccentricity squared\n        const n = (a-b)/(a+b), n2 = n*n, n3 = n*n*n;         // n, n, n\n\n        const cos = Math.cos(), sin = Math.sin();\n        const  = a*F0/Math.sqrt(1-e2*sin*sin);            // nu = transverse radius of curvature\n        const  = a*F0*(1-e2)/Math.pow(1-e2*sin*sin, 1.5); // rho = meridional radius of curvature\n        const 2 = /-1;                                    // eta = ?\n\n        const Ma = (1 + n + (5/4)*n2 + (5/4)*n3) * (-0);\n        const Mb = (3*n + 3*n*n + (21/8)*n3) * Math.sin(-0) * Math.cos(+0);\n        const Mc = ((15/8)*n2 + (15/8)*n3) * Math.sin(2*(-0)) * Math.cos(2*(+0));\n        const Md = (35/24)*n3 * Math.sin(3*(-0)) * Math.cos(3*(+0));\n        const M = b * F0 * (Ma - Mb + Mc - Md);              // meridional arc\n\n        const cos3 = cos*cos*cos;\n        const cos5 = cos3*cos*cos;\n        const tan2 = Math.tan()*Math.tan();\n        const tan4 = tan2*tan2;\n\n        const I = M + N0;\n        const II = (/2)*sin*cos;\n        const III = (/24)*sin*cos3*(5-tan2+9*2);\n        const IIIA = (/720)*sin*cos5*(61-58*tan2+tan4);\n        const IV = *cos;\n        const V = (/6)*cos3*(/-tan2);\n        const VI = (/120) * cos5 * (5 - 18*tan2 + tan4 + 14*2 - 58*tan2*2);\n\n        const  = -0;\n        const 2 = *, 3 = 2*, 4 = 3*, 5 = 4*, 6 = 5*;\n\n        let N = I + II*2 + III*4 + IIIA*6;\n        let E = E0 + IV* + V*3 + VI*5;\n\n        N = Number(N.toFixed(3)); // round to mm precision\n        E = Number(E.toFixed(3));\n\n        try {\n            return new OsGridRef(E, N); // note: gets truncated to SW corner of 1m grid square\n        } catch (e) {\n            throw new Error(`${e.message} from (${point.lat.toFixed(6)},${point.lon.toFixed(6)}).toOsGrid()`);\n        }\n    }\n\n\n    /**\n     * Override LatLonEllipsoidal.convertDatum() with version which returns LatLon_OsGridRef.\n     */\n    convertDatum(toDatum) {\n        const osgbED = super.convertDatum(toDatum); // returns LatLonEllipsoidal_Datum\n        const osgbOSGR = new LatLon_OsGridRef(osgbED.lat, osgbED.lon, osgbED.height, osgbED.datum);\n        return osgbOSGR;\n    }\n\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nexport { OsGridRef as default, LatLon_OsGridRef as LatLon, Dms };\n","import { distance as turfDistance } from '@turf/distance'\nimport { point as TurfPoint } from '@turf/helpers'\nimport { defaults } from '../store/constants'\n\nconst getBearing = (coord1, coord2) => {\n  const east = coord1[0] < coord2[0] && 'east'\n  const west = coord1[0] > coord2[0] && 'west'\n  const north = coord1[1] < coord2[1] && 'north'\n  const south = coord1[1] > coord2[1] && 'south'\n  return [east, west, north, south].filter(b => b && typeof b === 'string')\n}\n\nconst getUnits = (metres) => {\n  const MAX_METRES = 800\n  const MAX_MILES = 5000\n  const RATIO = 0.621371\n  let units\n  if (metres < MAX_METRES) {\n    units = `${metres} metres`\n  } else if (metres < MAX_MILES) {\n    units = (metres / 1000 * RATIO).toFixed(1) + ' miles'\n  } else {\n    units = Math.round((metres / 1000) * RATIO) + ' miles'\n  }\n  return units\n}\n\nconst getDirection = (coord1, coord2) => {\n  coord1 = coord1.map(n => n > 1000 ? Math.round(n) : Math.round(n * 100000) / 100000)\n  coord2 = coord2.map(n => n > 1000 ? Math.round(n) : Math.round(n * 100000) / 100000)\n  const ns1 = [coord1[0], coord1[1]]\n  const ns2 = [coord1[0], coord2[1]]\n  const ew1 = [coord1[0], coord1[1]]\n  const ew2 = [coord2[0], coord1[1]]\n  const nsd = getDistance(ns1, ns2)\n  const ewd = getDistance(ew1, ew2)\n  const bearing = getBearing(coord1, coord2)\n  const ewc = bearing.filter(b => ['east', 'west'].includes(b)).join('')\n  const nsc = bearing.filter(b => ['north', 'south'].includes(b)).join('')\n  const ew = ewc ? `${ewc} ${getUnits(ewd)}` : ''\n  const ns = nsc ? `${nsc} ${getUnits(nsd)}` : ''\n  return `${ns + (ewc && nsc ? ', ' : '') + ew}`\n}\n\nconst getArea = (bounds) => {\n  const ew = getDistance([bounds[0], bounds[1]], [bounds[2], bounds[1]])\n  const ns = getDistance([bounds[0], bounds[1]], [bounds[0], bounds[3]])\n  return `${getUnits(ew)} by ${getUnits(ns)}`\n}\n\nconst getBoundsChange = (oCentre, originalZoom, isMaxZoom, isMinZoom, center, zoom) => {\n  const isSameCentre = JSON.stringify(oCentre) === JSON.stringify(center)\n  const isSameZoom = originalZoom === zoom\n  const isMove = oCentre && originalZoom && !(isSameCentre && isSameZoom)\n  const maxZoom = isMaxZoom ? ' (Maximum zoom reached)' : ''\n  const minZoom = isMinZoom ? ' (Minimum zoom reached)' : ''\n  let change = ''\n  if (isMove) {\n    if (!isSameCentre && !isSameZoom) {\n      change = `New area${maxZoom}${minZoom}: `\n    } else if (!isSameCentre) {\n      change = `Map move: ${getDirection(oCentre, center)}, `\n    } else {\n      const direction = zoom > originalZoom ? 'in' : 'out'\n      change = `Zoomed ${direction}${maxZoom}${minZoom}: `\n    }\n  }\n  return change\n}\n\nconst getSelectedStatus = (featuresInViewport, id) => {\n  const total = featuresInViewport.length\n  const index = featuresInViewport.findIndex(f => f.id === id)\n  return index >= 0 && `${total} feature${total !== 1 ? 's' : ''} in this area. ${featuresInViewport[index].name}. ${index + 1} of ${total} highlighted.`\n}\n\nconst getOffsetBoundingClientRect = (el) => {\n  const offsetParent = el.closest('[data-fm-main]') || document.body\n  return offsetParent.getBoundingClientRect()\n}\n\nconst isCirclePolygon = (geometry) => {\n  const coordinates = geometry?.coordinates?.[0]\n\n  // Expect exactly 64 points\n  if (coordinates?.length !== 65) {\n    return false\n  }\n\n  // Compute approximate centre using two opposite points\n  const [x1, y1] = coordinates[0]\n  const [x2, y2] = coordinates[32]\n  const center = [(x1 + x2) / 2, (y1 + y2) / 2]\n\n  let minDist = Infinity; let maxDist = -Infinity\n  let minEdge = Infinity; let maxEdge = -Infinity\n\n  for (let i = 0; i < 64; i++) {\n    const [xA, yA] = coordinates[i]\n    const [xB, yB] = coordinates[(i + 1) % 64]\n\n    // Distance from center\n    const dist = Math.hypot(xA - center[0], yA - center[1])\n    minDist = Math.min(minDist, dist)\n    maxDist = Math.max(maxDist, dist)\n\n    // Distance to next vertex (edge length)\n    const edgeDist = Math.hypot(xB - xA, yB - yA)\n    minEdge = Math.min(minEdge, edgeDist)\n    maxEdge = Math.max(maxEdge, edgeDist)\n  }\n\n  // Need to revist tolerance as they depend on size too\n  const WSG84_TOLERANCE = 0.3\n  const BNG_TOLERANCE = 0.3\n  const tolerance = detectCoordinateType(center) === 'WSG84' ? WSG84_TOLERANCE : BNG_TOLERANCE\n\n  return Math.abs(maxDist - minDist) < tolerance && Math.abs(maxEdge - minEdge) < tolerance\n}\n\nconst metresToImperial = (metres) => {\n  const MILE = 1609.344\n  const YARD = 0.9144\n  const pluralize = (value, singular, plural) => `${value} ${value === 1 ? singular : plural}`\n  if (metres >= MILE) {\n    const miles = Math.floor(metres / MILE)\n    const remainder = metres % MILE\n    const yards = Math.floor(remainder / YARD)\n    return `${pluralize(miles, 'mile', 'miles')}, ${pluralize(yards, 'yard', 'yards')}`\n  } else {\n    const yards = Math.floor(metres / YARD)\n    return `${pluralize(yards, 'yard', 'yards')}`\n  }\n}\n\nconst squareMetresToKm = (metres) => {\n  const SQ_KM = 1_000_000\n  if (metres >= SQ_KM) {\n    let km2 = (metres / SQ_KM).toFixed(2)\n    km2 = Number(km2).toLocaleString(undefined, { minimumFractionDigits: 0, maximumFractionDigits: 2 })\n    return `${km2} km`\n  } else {\n    return `${Math.ceil(metres).toLocaleString()} m`\n  }\n}\n\nexport const parseDimensions = (dimensions) => {\n  const { area, length } = dimensions\n  const areaDisplay = area ? squareMetresToKm(area) : null\n  const lengthDisplay = length ? metresToImperial(length) : null\n  return { ...dimensions, areaDisplay, lengthDisplay }\n}\n\nexport const detectCoordinateType = (coords) => {\n  if (coords.length === 3) {\n    return 'BNG' // If a third value exists (zone), it's UTM\n  }\n  const [x, y] = coords\n  if (x >= -180 && x <= 180 && y >= -90 && y <= 90) {\n    return 'WSG84'\n  }\n  if (x > 180 && y > 90) {\n    return 'BNG'\n  }\n  return 'Unknown'\n}\n\nexport const getDistance = (coord1, coord2) => {\n  let distance\n  if (coord1[0] > 1000) {\n    const x = Math.abs(coord1[0] - coord2[0])\n    const y = Math.abs(coord1[1] - coord2[1])\n    const dist = Math.sqrt((Math.pow(x, 2)) + (Math.pow(y, 2)))\n    distance = dist\n  } else {\n    const p1 = new TurfPoint(coord1)\n    const p2 = new TurfPoint(coord2)\n    distance = turfDistance(p1, p2, { units: 'metres' })\n  }\n  return Math.round(distance)\n}\n\nexport const getFocusPadding = (el, scale) => {\n  let padding\n  if (el) {\n    const parent = getOffsetBoundingClientRect(el)\n    const box = el.getBoundingClientRect()\n    const boxX = box.x || box.left\n    const boxY = box.y || box.top\n    const parentX = parent.x || parent.left\n    const parentY = parent.y || parent.top\n    padding = {\n      top: (boxY - parentY) / scale,\n      left: (boxX - parentX) / scale,\n      right: (parent.width - box.width - (boxX - parentX)) / scale,\n      bottom: (parent.height - box.height - (boxY - parentY)) / scale\n    }\n  }\n  // Addresses repid browser resizing\n  const isValid = Object.values(padding).every(i => i >= 0)\n  return isValid && padding\n}\n\nexport const getFocusBounds = (el, scale) => {\n  let bounds\n  if (el) {\n    const parent = getOffsetBoundingClientRect(el)\n    const box = el.getBoundingClientRect()\n    const m = 10\n    bounds = [[\n      ((box.x || box.left) - (parent.x || parent.left) + m) / scale,\n      (((box.y || box.top) - (parent.y || parent.top)) + box.height - m) / scale\n    ], [\n      (box.width + ((box.x || box.left) - (parent.x || parent.left)) - m) / scale,\n      ((box.y || box.top) - (parent.y || parent.top) + m) / scale\n    ]]\n  }\n  return bounds\n}\n\nexport const getMapPixel = (el, scale) => {\n  const parent = getOffsetBoundingClientRect(el)\n  const box = el.getBoundingClientRect()\n  const left = ((box.x || box.left) - (parent.x || parent.left)) / scale\n  const top = ((box.y || box.top) - (parent.y || parent.top)) / scale\n  const offsetLeft = (box.width / 2) / scale\n  const offsetTop = (box.height / 2) / scale\n  const point = [left + offsetLeft, top + offsetTop]\n  return point\n}\n\nexport const getDescription = (place, bounds, features) => {\n  const { featuresTotal, isFeaturesInMap, isPixelFeaturesAtPixel, isPixelFeaturesInMap } = features || {}\n  let text = ''\n\n  if (featuresTotal) {\n    text = `${featuresTotal} feature${featuresTotal === 1 ? '' : 's'} in this area. `\n  } else if (isPixelFeaturesAtPixel) {\n    text = 'Data visible at the center coordinate. '\n  } else if (isPixelFeaturesInMap) {\n    text = 'No data visible at the center coordinate. '\n  } else if (isFeaturesInMap) {\n    text = 'No feature data in this area. '\n  } else {\n    // Null\n  }\n\n  const focusPlace = place ? `approximate centre ${place}, ` : ''\n  const focusArea = `covering ${getArea(bounds)}`\n  const findPlace = place ? '' : 'Use ALT plus I to find closest place'\n\n  return `${focusPlace}${focusArea}. ${text}${findPlace}`\n}\n\nexport const getStatus = (action, isBoundsChange, place, state, current) => {\n  const { center, bounds, zoom, isMaxZoom, isMinZoom, features, label, selectedId } = current\n  let status = null\n  if (label) {\n    status = label\n  } else if (selectedId) {\n    const selected = getSelectedStatus(features?.featuresInViewport, selectedId)\n    status = selected\n  } else if (action === 'DATA') {\n    status = 'Map change: new data. Use ALT plus I to get new details'\n  } else if (isBoundsChange) {\n    const direction = getBoundsChange(state.center, state.zoom, isMaxZoom, isMinZoom, center, zoom)\n    const description = getDescription(place, bounds, features)\n    status = `${direction}${direction ? 'f' : 'F'}ocus area ${description}`\n  } else {\n    status = ''\n  }\n  return status\n}\n\nexport const getPlace = (isUserInitiated, action, oPlace, newPlace) => {\n  let place\n  if (!isUserInitiated) {\n    if (action === 'RESET') {\n      place = oPlace\n    } else {\n      place = newPlace\n    }\n  }\n  return place\n}\n\nexport const parseCentre = (value, srid) => {\n  const mb = defaults[`MAX_BOUNDS_${srid}`]\n  let isInRange\n  let coords = value?.split(',')\n  // Query string formed correctly\n  if (!(Array.isArray(coords) && coords?.length === 3)) {\n    return null\n  }\n  // Coords are numbers\n  coords = coords.slice(0, 2).map(x => parseFloat(x))\n  coords = !coords.some(isNaN) && coords\n  if (!coords) {\n    return null\n  }\n  // Coords are within the valid range\n  if (srid === '27700') {\n    isInRange = !!coords.filter(c => c >= 0).length\n  } else {\n    isInRange = (coords[0] > mb[0] && coords[0] < mb[2]) && (coords[1] > mb[1] && coords[1] < mb[3])\n  }\n  return isInRange ? coords : null\n}\n\nexport const parseZoom = value => {\n  const coords = value?.split(',')\n  if (!(Array.isArray(coords) && coords?.length === 3)) {\n    return null\n  }\n  const zoom = parseFloat(coords[2])\n  return !zoom.isNaN ? zoom : null\n}\n\nexport const getShortcutKey = (e, featuresViewport) => {\n  const number = e.code.slice(-1)\n  const hasFeature = featuresViewport.length >= number\n  const id = hasFeature ? featuresViewport[number - 1].id : ''\n  return id\n}\n\nexport const getFeatureShape = (feature) => {\n  if (isCirclePolygon(feature?.geometry)) {\n    return 'circle'\n  }\n  if (feature?.geometry?.type?.toLowerCase() === 'polygon') {\n    const coords = feature.geometry?.coordinates\n    const flatCoords = (coords && Array.from(new Set(coords.flat(2)))) || null\n    return flatCoords?.length === 4 ? 'square' : 'polygon'\n  }\n  return null\n}\n\nexport const spatialNavigate = (direction, start, pixels) => {\n  const quadrant = pixels.filter(p => {\n    const offsetX = Math.abs(p[0] - start[0])\n    const offsetY = Math.abs(p[1] - start[1])\n    let isQuadrant = false\n    if (direction === 'up') {\n      isQuadrant = p[1] <= start[1] && offsetY >= offsetX\n    } else if (direction === 'down') {\n      isQuadrant = p[1] > start[1] && offsetY >= offsetX\n    } else if (direction === 'left') {\n      isQuadrant = p[0] <= start[0] && offsetY < offsetX\n    } else {\n      isQuadrant = p[0] > start[0] && offsetY < offsetX\n    }\n    return isQuadrant && (JSON.stringify(p) !== JSON.stringify(start))\n  })\n  if (!quadrant.length) {\n    quadrant.push(start)\n  }\n  const pythagorean = (a, b) => Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2))\n  const distances = quadrant.map(p => pythagorean(Math.abs(start[0] - p[0]), Math.abs(start[1] - p[1])))\n  const closest = quadrant[distances.indexOf(Math.min(...distances))]\n  return pixels.findIndex(i => JSON.stringify(i) === JSON.stringify(closest))\n}\n\nexport const getScale = (size) => {\n  return { small: 1, medium: 1.5, large: 2 }[size] || 1\n}\n\nexport const getPoint = (el, e, scale) => {\n  const { left, top } = el.getBoundingClientRect()\n  const { clientX, clientY } = e.nativeEvent\n  const x = clientX - left\n  const y = clientY - top\n  return [x / scale, y / scale]\n}\n\nexport const getStyle = (styles = []) => {\n  const validStyles = styles.filter(s => defaults.STYLES.includes(s.name))\n  const style = window.localStorage.getItem('style')\n  return validStyles.find(s => s.name === style) || validStyles.find(s => s.name === 'default')\n}\n","import config from './config.json'\nimport { detectCoordinateType } from '../../lib/viewport'\nimport { LatLon } from 'geodesy/osgridref.js'\n\nconst place = ({ NAME1, POPULATED_PLACE, COUNTY_UNITARY, REGION }) => {\n  return `${NAME1}${POPULATED_PLACE ? ', ' + POPULATED_PLACE : ''}${COUNTY_UNITARY ? ', ' + COUNTY_UNITARY : ''}, ${REGION}`\n}\n\nclass ReverseGeocode {\n  constructor (transformGeocodeRequest = (u) => u) {\n    this.transformGeocodeRequest = transformGeocodeRequest\n  }\n\n  async getNearest (zoom, coord) {\n    // Need to convert WSG84 to BNG\n    if (detectCoordinateType(coord) === 'WSG84') {\n      try {\n        const bng = (new LatLon(coord[1], coord[0])).toOsGrid()\n        coord = [bng.easting, bng.northing]\n      } catch (err) {\n        console.log(err)\n        return null\n      }\n    }\n\n    let url = config.OS_NEAREST_URL\n    url = url.replace('{easting}', Math.round(coord[0])).replace('{northing}', Math.round(coord[1]))\n    const response = await fetch(await this.transformGeocodeRequest(url))\n    const json = await response.json()\n    return json.results ? place(json.results[0].GAZETTEER_ENTRY) : null\n  }\n}\n\nexport default ReverseGeocode\n"],"names":["getCoord","coord","Error","Array","isArray","type","geometry","coordinates","length","getGeom","geojson","earthRadius","factors","centimeters","centimetres","degrees","Math","PI","feet","inches","kilometers","kilometres","meters","metres","miles","millimeters","millimetres","nauticalmiles","radians","yards","feature","geom","properties","options","feat","id","bbox","point","isNumber","polygon","ring","j","lineString","multiLineString","multiPolygon","radiansToLength","units","factor","lengthToRadians","distance","radiansToDegrees","degreesToRadians","num","isNaN","from","to","coordinates1","coordinates2","dLat","dLon","lat1","lat2","a","pow","sin","cos","atan2","sqrt","_regeneratorRuntime","e","t","r","Object","prototype","n","hasOwnProperty","o","defineProperty","value","i","Symbol","iterator","c","asyncIterator","u","toStringTag","define","enumerable","configurable","writable","wrap","Generator","create","Context","makeInvokeMethod","tryCatch","arg","call","h","l","f","s","y","GeneratorFunction","GeneratorFunctionPrototype","p","d","getPrototypeOf","v","values","g","defineIteratorMethods","forEach","_invoke","AsyncIterator","invoke","_typeof","resolve","__await","then","callInvokeWithMethodAndArg","done","method","delegate","maybeInvokeDelegate","sent","_sent","dispatchException","abrupt","return","TypeError","resultName","next","nextLoc","pushTryEntry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","displayName","isGeneratorFunction","constructor","name","mark","setPrototypeOf","__proto__","awrap","async","Promise","keys","reverse","pop","prev","charAt","slice","stop","rval","handle","complete","finish","catch","delegateYield","asyncGeneratorStep","_asyncToGenerator","arguments","apply","_next","_throw","_toConsumableArray","_arrayLikeToArray","_arrayWithoutHoles","_iterableToArray","toString","test","_unsupportedIterableToArray","_nonIterableSpread","removeNonEngland","results","filter","GAZETTEER_ENTRY","COUNTRY","toLowerCase","removeDuplicates","Map","map","result","ID","removeTenuousResults","query","words","replace","split","some","w","NAME1","includes","markString","string","find","patterns","Set","concat","trim","join","reg","RegExp","__html","suggestion","_ref2","COUNTY_UNITARY","DISTRICT_BOROUGH","POSTCODE_DISTRICT","LOCAL_TYPE","qualifier","text","marked","parseResults","_ref3","_callee","transformGeocodeRequest","url","response","json","_context","config","encodeURI","t0","fetch","t1","error","header","totalresults","t2","console","log","_x","_x2","Geocode","undefined","_classCallCheck","this","key","_suggest","_callee2","_context2","_x3","_find","_callee3","_context3","MBR_XMIN","MBR_YMIN","MBR_XMAX","MBR_YMAX","GEOMETRY_X","GEOMETRY_Y","_ref","bounds","OsGridRef","toLatLon","lon","lat","round","center","_x4","dmsSeparator","Dms","separator","char","parse","dms","parseFloat","isFinite","Number","dmsParts","String","splice","NaN","deg","toDms","format","dp","Infinity","abs","m","toFixed","floor","toLat","wrap90","toLon","wrap180","toBrng","brng","wrap360","fromLocale","str","locale","toLocaleString","thousands","decimal","toLocale","compassPoint","bearing","precision","RangeError","x","toRadians","toDegrees","Vector3d","z","plus","minus","times","dividedBy","dot","cross","negate","unit","norm","angleTo","sign","rotateAround","axis","angle","rp","ellipsoids","WGS84","b","datums","ellipsoid","freeze","LatLonEllipsoidal","height","_lat","_lon","_height","latitude","lng","longitude","datum","_datum","args","ll","JSON","stringify","toCartesian","referenceFrame","eSq","Cartesian","equals","EPSILON","epoch","dpHeight","super","e2","Airy1830","AiryModified","Bessel1841","Clarke1866","Clarke1880IGN","GRS80","Intl1924","WGS72","ED50","transform","ETRS89","Irl1975","NAD27","NAD83","NTF","OSGB36","Potsdam","TokyoJapan","LatLonEllipsoidal_Datum","convertDatum","toDatum","cartesian","Cartesian_Datum","deprecatedDatum","info","latLon","oldCartesian","newCartesian","applyTransform","x1","y1","z1","tx","ty","tz","rx","ry","rz","nationalGrid","trueOrigin","falseOrigin","easting","northing","scaleFactor","E","N","E0","N0","F0","n2","n3","M","tan","dE","dE2","dE3","dE4","dE5","LatLon_OsGridRef","gridref","match","l1","toUpperCase","charCodeAt","l2","e100km","n100km","en","padEnd","digits","useGrouping","minimumIntegerDigits","maximumFractionDigits","letterPair","fromCharCode","padStart","toOsGrid","message","osgbED","getUnits","RATIO","getOffsetBoundingClientRect","el","closest","document","body","getBoundingClientRect","parseDimensions","dimensions","area","areaDisplay","SQ_KM","km2","minimumFractionDigits","ceil","squareMetresToKm","lengthDisplay","MILE","YARD","pluralize","singular","plural","remainder","metresToImperial","_objectSpread","detectCoordinateType","coords","_coords","_slicedToArray","getDistance","coord1","coord2","p1","TurfPoint","p2","turfDistance","getFocusPadding","scale","padding","parent","box","boxX","left","boxY","top","parentX","parentY","right","width","bottom","every","getFocusBounds","getMapPixel","getDescription","place","features","featuresTotal","isFeaturesInMap","isPixelFeaturesAtPixel","isPixelFeaturesInMap","focusPlace","focusArea","ew","ns","getArea","findPlace","getStatus","action","isBoundsChange","state","current","featuresInViewport","total","index","zoom","isMaxZoom","isMinZoom","label","selectedId","status","findIndex","direction","oCentre","originalZoom","isSameCentre","isSameZoom","maxZoom","minZoom","change","ns1","ns2","ew1","ew2","nsd","ewd","getBearing","ewc","nsc","getDirection","getBoundsChange","description","getPlace","isUserInitiated","oPlace","newPlace","parseCentre","srid","_coords2","mb","defaults","parseZoom","getShortcutKey","featuresViewport","number","code","getFeatureShape","_feature$geometry","_geometry$coordinates","_coordinates$","_coordinates$2","minDist","maxDist","minEdge","maxEdge","_coordinates$i","xA","yA","_coordinates","xB","yB","dist","hypot","min","max","edgeDist","tolerance","isCirclePolygon","_feature$geometry2","flatCoords","flat","spatialNavigate","start","pixels","quadrant","offsetX","offsetY","distances","indexOf","getScale","size","small","medium","large","getPoint","_el$getBoundingClient","_e$nativeEvent","nativeEvent","clientX","clientY","getStyle","validStyles","STYLES","style","window","localStorage","getItem","_defineProperties","_toPropertyKey","toPrimitive","_toPrimitive","ReverseGeocode","bng","LatLon","POPULATED_PLACE","REGION","_getNearest"],"sourceRoot":""}