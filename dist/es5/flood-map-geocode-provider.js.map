{"version":3,"file":"flood-map-geocode-provider.js","mappings":"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","sources":["webpack://@defra/flood-map/./src/js/provider/os-open-names/geocode.js","webpack://@defra/flood-map/./node_modules/geodesy/dms.js","webpack://@defra/flood-map/./node_modules/geodesy/vector3d.js","webpack://@defra/flood-map/./node_modules/geodesy/latlon-ellipsoidal.js","webpack://@defra/flood-map/./node_modules/geodesy/latlon-ellipsoidal-datum.js","webpack://@defra/flood-map/./node_modules/geodesy/osgridref.js"],"sourcesContent":["import OsGridRef from 'geodesy/osgridref.js'\nimport config from './config.json'\n\nconst isPostcode = (value) => {\n  value = value.replace(/\\s/g, '')\n  const regex = /^(([A-Z]{1,2}\\d[A-Z\\d]?|ASCN|STHL|TDCU|BBND|[BFS]IQQ|PCRN|TKCA) ?\\d[A-Z]{2}|BFPO ?\\d{1,4}|(KY\\d|MSR|VG|AI)[ -]?\\d{4}|[A-Z]{2} ?\\d{2}|GE ?CX|GIR ?0A{2}|SAN ?TA1)$/i\n  return regex.test(value)\n}\n\n// Exclude Scotalnd, Wales and Northern Ireland results\nconst removeNonEngland = (results) => {\n  return results.filter(r => r.GAZETTEER_ENTRY.COUNTRY.toLowerCase() === 'england')\n}\n\n// Remove duplicates (OS API bug?) eg: 'Newcastle upon Tyne'\nconst removeDuplicates = (results) => {\n  return Array.from(new Map(results.map(result => [result.GAZETTEER_ENTRY.ID, result])).values())\n}\n\n// Remove any item that doesnt contain a part of the query in name1\nconst removeTenuousResults = (results, query) => {\n  const words = query.toLowerCase().replace(/,/g, '').split(' ')\n  return results.filter(l => words.some(w => l.GAZETTEER_ENTRY.NAME1.toLowerCase().includes(w)))\n}\n\n// Mark search charcaters in result\nconst markString = (string, find) => {\n  find = find.replace(/,/g, '')\n  const patterns = [...new Set([find, ...find.trim().split(/[stn]+/)])].join('|')\n  const reg = new RegExp(`(${patterns})`, 'i', 'g', 'gi')\n  return { __html: string.replace(reg, '<mark>$1</mark>') }\n}\n\nconst place = ({ ID, NAME1, MBR_XMIN, MBR_YMIN, MBR_XMAX, MBR_YMAX, GEOMETRY_X, GEOMETRY_Y }) => {\n  const bounds = MBR_XMIN\n    ? [\n        (new OsGridRef(MBR_XMIN, MBR_YMIN)).toLatLon().lon,\n        (new OsGridRef(MBR_XMIN, MBR_YMIN)).toLatLon().lat,\n        (new OsGridRef(MBR_XMAX, MBR_YMAX)).toLatLon().lon,\n        (new OsGridRef(MBR_XMAX, MBR_YMAX)).toLatLon().lat]\n        .map(n => Math.round(n * 1000000) / 1000000)\n    : [\n        (new OsGridRef(GEOMETRY_X - config.POINT_BUFFER, GEOMETRY_Y - config.POINT_BUFFER)).toLatLon().lon,\n        (new OsGridRef(GEOMETRY_X - config.POINT_BUFFER, GEOMETRY_Y - config.POINT_BUFFER)).toLatLon().lat,\n        (new OsGridRef(GEOMETRY_X + config.POINT_BUFFER, GEOMETRY_Y + config.POINT_BUFFER)).toLatLon().lon,\n        (new OsGridRef(GEOMETRY_X + config.POINT_BUFFER, GEOMETRY_Y + config.POINT_BUFFER)).toLatLon().lat]\n        .map(n => Math.round(n * 1000000) / 1000000)\n  const center = GEOMETRY_X\n    ? [(new OsGridRef(GEOMETRY_X, GEOMETRY_Y)).toLatLon().lon,\n        (new OsGridRef(GEOMETRY_X, GEOMETRY_Y)).toLatLon().lat]\n        .map(n => Math.round(n * 1000000) / 1000000)\n    : null\n\n  return {\n    id: ID,\n    text: NAME1,\n    bounds,\n    center\n  }\n}\n\nconst suggestion = (query, { ID, NAME1, COUNTY_UNITARY, DISTRICT_BOROUGH, POSTCODE_DISTRICT, LOCAL_TYPE }) => {\n  const qualifier = `${!['City', 'Postcode'].includes(LOCAL_TYPE) ? POSTCODE_DISTRICT + ', ' : ''}${LOCAL_TYPE !== 'City' ? (COUNTY_UNITARY || DISTRICT_BOROUGH) : ''}`\n  const text = `${NAME1}${qualifier ? ', ' + qualifier : ''}`\n\n  return {\n    id: ID,\n    text: `${NAME1}${qualifier ? ', ' + qualifier : ''}`,\n    marked: markString(text, query)\n  }\n}\n\nconst parseResults = async (query, transformGeocodeRequest) => {\n  if (!query) {\n    return []\n  }\n  let url = config.URL\n  url = url.replace('{query}', encodeURI(query)).replace('{maxresults}', isPostcode(query) ? 1 : 100)\n  let results = []\n  try {\n    const response = await fetch(await transformGeocodeRequest(url))\n    const json = await response.json()\n    if (json.error || json.header.totalresults === 0) {\n      return []\n    }\n    results = removeTenuousResults(json.results, query)\n    results = removeDuplicates(results)\n    results = removeNonEngland(results)\n    results = results.slice(0, 8)\n  } catch (err) {\n    console.log(err)\n  }\n  return results\n}\n\nclass Geocode {\n  constructor (transformGeocodeRequest = (u) => u) {\n    this.transformGeocodeRequest = transformGeocodeRequest\n  }\n\n  async suggest (query) {\n    if (!query) {\n      return []\n    }\n    const results = await parseResults(query, this.transformGeocodeRequest)\n    return results.map(l => suggestion(query, l.GAZETTEER_ENTRY))\n  }\n\n  async find (query) {\n    if (!query) {\n      return null\n    }\n    const results = await parseResults(query, this.transformGeocodeRequest)\n    return results.length ? place(results[0].GAZETTEER_ENTRY) : null\n  }\n}\n\nexport default Geocode\n","/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/* Geodesy representation conversion functions                        (c) Chris Veness 2002-2020  */\n/*                                                                                   MIT Licence  */\n/* www.movable-type.co.uk/scripts/latlong.html                                                    */\n/* www.movable-type.co.uk/scripts/js/geodesy/geodesy-library.html#dms                             */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n/* eslint no-irregular-whitespace: [2, { skipComments: true }] */\n\n\n/**\n * Latitude/longitude points may be represented as decimal degrees, or subdivided into sexagesimal\n * minutes and seconds. This module provides methods for parsing and representing degrees / minutes\n * / seconds.\n *\n * @module dms\n */\n\n\n/* Degree-minutes-seconds (& cardinal directions) separator character */\nlet dmsSeparator = '\\u202f'; // U+202F = 'narrow no-break space'\n\n\n/**\n * Functions for parsing and representing degrees / minutes / seconds.\n */\nclass Dms {\n\n    // note Unicode Degree = U+00B0. Prime = U+2032, Double prime = U+2033\n\n    /**\n     * Separator character to be used to separate degrees, minutes, seconds, and cardinal directions.\n     *\n     * Default separator is U+202F ‘narrow no-break space’.\n     *\n     * To change this (e.g. to empty string or full space), set Dms.separator prior to invoking\n     * formatting.\n     *\n     * @example\n     *   import LatLon, { Dms } from '/js/geodesy/latlon-spherical.js';\n     *   const p = new LatLon(51.2, 0.33).toString('dms');  // 51° 12′ 00″ N, 000° 19′ 48″ E\n     *   Dms.separator = '';                                // no separator\n     *   const pʹ = new LatLon(51.2, 0.33).toString('dms'); // 51°12′00″N, 000°19′48″E\n     */\n    static get separator()     { return dmsSeparator; }\n    static set separator(char) { dmsSeparator = char; }\n\n\n    /**\n     * Parses string representing degrees/minutes/seconds into numeric degrees.\n     *\n     * This is very flexible on formats, allowing signed decimal degrees, or deg-min-sec optionally\n     * suffixed by compass direction (NSEW); a variety of separators are accepted. Examples -3.62,\n     * '3 37 12W', '3°37′12″W'.\n     *\n     * Thousands/decimal separators must be comma/dot; use Dms.fromLocale to convert locale-specific\n     * thousands/decimal separators.\n     *\n     * @param   {string|number} dms - Degrees or deg/min/sec in variety of formats.\n     * @returns {number}        Degrees as decimal number.\n     *\n     * @example\n     *   const lat = Dms.parse('51° 28′ 40.37″ N');\n     *   const lon = Dms.parse('000° 00′ 05.29″ W');\n     *   const p1 = new LatLon(lat, lon); // 51.4779°N, 000.0015°W\n     */\n    static parse(dms) {\n        // check for signed decimal degrees without NSEW, if so return it directly\n        if (!isNaN(parseFloat(dms)) && isFinite(dms)) return Number(dms);\n\n        // strip off any sign or compass dir'n & split out separate d/m/s\n        const dmsParts = String(dms).trim().replace(/^-/, '').replace(/[NSEW]$/i, '').split(/[^0-9.,]+/);\n        if (dmsParts[dmsParts.length-1]=='') dmsParts.splice(dmsParts.length-1);  // from trailing symbol\n\n        if (dmsParts == '') return NaN;\n\n        // and convert to decimal degrees...\n        let deg = null;\n        switch (dmsParts.length) {\n            case 3:  // interpret 3-part result as d/m/s\n                deg = dmsParts[0]/1 + dmsParts[1]/60 + dmsParts[2]/3600;\n                break;\n            case 2:  // interpret 2-part result as d/m\n                deg = dmsParts[0]/1 + dmsParts[1]/60;\n                break;\n            case 1:  // just d (possibly decimal) or non-separated dddmmss\n                deg = dmsParts[0];\n                // check for fixed-width unseparated format eg 0033709W\n                //if (/[NS]/i.test(dmsParts)) deg = '0' + deg;  // - normalise N/S to 3-digit degrees\n                //if (/[0-9]{7}/.test(deg)) deg = deg.slice(0,3)/1 + deg.slice(3,5)/60 + deg.slice(5)/3600;\n                break;\n            default:\n                return NaN;\n        }\n        if (/^-|[WS]$/i.test(dms.trim())) deg = -deg; // take '-', west and south as -ve\n\n        return Number(deg);\n    }\n\n\n    /**\n     * Converts decimal degrees to deg/min/sec format\n     *  - degree, prime, double-prime symbols are added, but sign is discarded, though no compass\n     *    direction is added.\n     *  - degrees are zero-padded to 3 digits; for degrees latitude, use .slice(1) to remove leading\n     *    zero.\n     *\n     * @private\n     * @param   {number} deg - Degrees to be formatted as specified.\n     * @param   {string} [format=d] - Return value as 'd', 'dm', 'dms' for deg, deg+min, deg+min+sec.\n     * @param   {number} [dp=4|2|0] - Number of decimal places to use – default 4 for d, 2 for dm, 0 for dms.\n     * @returns {string} Degrees formatted as deg/min/secs according to specified format.\n     */\n    static toDms(deg, format='d', dp=undefined) {\n        if (isNaN(deg)) return null;  // give up here if we can't make a number from deg\n        if (typeof deg == 'string' && deg.trim() == '') return null;\n        if (typeof deg == 'boolean') return null;\n        if (deg == Infinity) return null;\n        if (deg == null) return null;\n\n        // default values\n        if (dp === undefined) {\n            switch (format) {\n                case 'd':   case 'deg':         dp = 4; break;\n                case 'dm':  case 'deg+min':     dp = 2; break;\n                case 'dms': case 'deg+min+sec': dp = 0; break;\n                default:          format = 'd'; dp = 4; break; // be forgiving on invalid format\n            }\n        }\n\n        deg = Math.abs(deg);  // (unsigned result ready for appending compass dir'n)\n\n        let dms = null, d = null, m = null, s = null;\n        switch (format) {\n            default: // invalid format spec!\n            case 'd': case 'deg':\n                d = deg.toFixed(dp);                       // round/right-pad degrees\n                if (d<100) d = '0' + d;                    // left-pad with leading zeros (note may include decimals)\n                if (d<10) d = '0' + d;\n                dms = d + '°';\n                break;\n            case 'dm': case 'deg+min':\n                d = Math.floor(deg);                       // get component deg\n                m = ((deg*60) % 60).toFixed(dp);           // get component min & round/right-pad\n                if (m == 60) { m = (0).toFixed(dp); d++; } // check for rounding up\n                d = ('000'+d).slice(-3);                   // left-pad with leading zeros\n                if (m<10) m = '0' + m;                     // left-pad with leading zeros (note may include decimals)\n                dms = d + '°'+Dms.separator + m + '′';\n                break;\n            case 'dms': case 'deg+min+sec':\n                d = Math.floor(deg);                       // get component deg\n                m = Math.floor((deg*3600)/60) % 60;        // get component min\n                s = (deg*3600 % 60).toFixed(dp);           // get component sec & round/right-pad\n                if (s == 60) { s = (0).toFixed(dp); m++; } // check for rounding up\n                if (m == 60) { m = 0; d++; }               // check for rounding up\n                d = ('000'+d).slice(-3);                   // left-pad with leading zeros\n                m = ('00'+m).slice(-2);                    // left-pad with leading zeros\n                if (s<10) s = '0' + s;                     // left-pad with leading zeros (note may include decimals)\n                dms = d + '°'+Dms.separator + m + '′'+Dms.separator + s + '″';\n                break;\n        }\n\n        return dms;\n    }\n\n\n    /**\n     * Converts numeric degrees to deg/min/sec latitude (2-digit degrees, suffixed with N/S).\n     *\n     * @param   {number} deg - Degrees to be formatted as specified.\n     * @param   {string} [format=d] - Return value as 'd', 'dm', 'dms' for deg, deg+min, deg+min+sec.\n     * @param   {number} [dp=4|2|0] - Number of decimal places to use – default 4 for d, 2 for dm, 0 for dms.\n     * @returns {string} Degrees formatted as deg/min/secs according to specified format.\n     *\n     * @example\n     *   const lat = Dms.toLat(-3.62, 'dms'); // 3°37′12″S\n     */\n    static toLat(deg, format, dp) {\n        const lat = Dms.toDms(Dms.wrap90(deg), format, dp);\n        return lat===null ? '–' : lat.slice(1) + Dms.separator + (deg<0 ? 'S' : 'N');  // knock off initial '0' for lat!\n    }\n\n\n    /**\n     * Convert numeric degrees to deg/min/sec longitude (3-digit degrees, suffixed with E/W).\n     *\n     * @param   {number} deg - Degrees to be formatted as specified.\n     * @param   {string} [format=d] - Return value as 'd', 'dm', 'dms' for deg, deg+min, deg+min+sec.\n     * @param   {number} [dp=4|2|0] - Number of decimal places to use – default 4 for d, 2 for dm, 0 for dms.\n     * @returns {string} Degrees formatted as deg/min/secs according to specified format.\n     *\n     * @example\n     *   const lon = Dms.toLon(-3.62, 'dms'); // 3°37′12″W\n     */\n    static toLon(deg, format, dp) {\n        const lon = Dms.toDms(Dms.wrap180(deg), format, dp);\n        return lon===null ? '–' : lon + Dms.separator + (deg<0 ? 'W' : 'E');\n    }\n\n\n    /**\n     * Converts numeric degrees to deg/min/sec as a bearing (0°..360°).\n     *\n     * @param   {number} deg - Degrees to be formatted as specified.\n     * @param   {string} [format=d] - Return value as 'd', 'dm', 'dms' for deg, deg+min, deg+min+sec.\n     * @param   {number} [dp=4|2|0] - Number of decimal places to use – default 4 for d, 2 for dm, 0 for dms.\n     * @returns {string} Degrees formatted as deg/min/secs according to specified format.\n     *\n     * @example\n     *   const lon = Dms.toBrng(-3.62, 'dms'); // 356°22′48″\n     */\n    static toBrng(deg, format, dp) {\n        const brng =  Dms.toDms(Dms.wrap360(deg), format, dp);\n        return brng===null ? '–' : brng.replace('360', '0');  // just in case rounding took us up to 360°!\n    }\n\n\n    /**\n     * Converts DMS string from locale thousands/decimal separators to JavaScript comma/dot separators\n     * for subsequent parsing.\n     *\n     * Both thousands and decimal separators must be followed by a numeric character, to facilitate\n     * parsing of single lat/long string (in which whitespace must be left after the comma separator).\n     *\n     * @param   {string} str - Degrees/minutes/seconds formatted with locale separators.\n     * @returns {string} Degrees/minutes/seconds formatted with standard Javascript separators.\n     *\n     * @example\n     *   const lat = Dms.fromLocale('51°28′40,12″N');                          // '51°28′40.12″N' in France\n     *   const p = new LatLon(Dms.fromLocale('51°28′40,37″N, 000°00′05,29″W'); // '51.4779°N, 000.0015°W' in France\n     */\n    static fromLocale(str) {\n        const locale = (123456.789).toLocaleString();\n        const separator = { thousands: locale.slice(3, 4), decimal: locale.slice(7, 8) };\n        return str.replace(separator.thousands, '⁜').replace(separator.decimal, '.').replace('⁜', ',');\n    }\n\n\n    /**\n     * Converts DMS string from JavaScript comma/dot thousands/decimal separators to locale separators.\n     *\n     * Can also be used to format standard numbers such as distances.\n     *\n     * @param   {string} str - Degrees/minutes/seconds formatted with standard Javascript separators.\n     * @returns {string} Degrees/minutes/seconds formatted with locale separators.\n     *\n     * @example\n     *   const Dms.toLocale('123,456.789');                   // '123.456,789' in France\n     *   const Dms.toLocale('51°28′40.12″N, 000°00′05.31″W'); // '51°28′40,12″N, 000°00′05,31″W' in France\n     */\n    static toLocale(str) {\n        const locale = (123456.789).toLocaleString();\n        const separator = { thousands: locale.slice(3, 4), decimal: locale.slice(7, 8) };\n        return str.replace(/,([0-9])/, '⁜$1').replace('.', separator.decimal).replace('⁜', separator.thousands);\n    }\n\n\n    /**\n     * Returns compass point (to given precision) for supplied bearing.\n     *\n     * @param   {number} bearing - Bearing in degrees from north.\n     * @param   {number} [precision=3] - Precision (1:cardinal / 2:intercardinal / 3:secondary-intercardinal).\n     * @returns {string} Compass point for supplied bearing.\n     *\n     * @example\n     *   const point = Dms.compassPoint(24);    // point = 'NNE'\n     *   const point = Dms.compassPoint(24, 1); // point = 'N'\n     */\n    static compassPoint(bearing, precision=3) {\n        if (![ 1, 2, 3 ].includes(Number(precision))) throw new RangeError(`invalid precision ‘${precision}’`);\n        // note precision could be extended to 4 for quarter-winds (eg NbNW), but I think they are little used\n\n        bearing = Dms.wrap360(bearing); // normalise to range 0..360°\n\n        const cardinals = [\n            'N', 'NNE', 'NE', 'ENE',\n            'E', 'ESE', 'SE', 'SSE',\n            'S', 'SSW', 'SW', 'WSW',\n            'W', 'WNW', 'NW', 'NNW' ];\n        const n = 4 * 2**(precision-1); // no of compass points at req’d precision (1=>4, 2=>8, 3=>16)\n        const cardinal = cardinals[Math.round(bearing*n/360)%n * 16/n];\n\n        return cardinal;\n    }\n\n\n    /**\n     * Constrain degrees to range -90..+90 (for latitude); e.g. -91 => -89, 91 => 89.\n     *\n     * @private\n     * @param {number} degrees\n     * @returns degrees within range -90..+90.\n     */\n    static wrap90(degrees) {\n        if (-90<=degrees && degrees<=90) return degrees; // avoid rounding due to arithmetic ops if within range\n\n        // latitude wrapping requires a triangle wave function; a general triangle wave is\n        //     f(x) = 4a/p ⋅ | (x-p/4)%p - p/2 | - a\n        // where a = amplitude, p = period, % = modulo; however, JavaScript '%' is a remainder operator\n        // not a modulo operator - for modulo, replace 'x%n' with '((x%n)+n)%n'\n        const x = degrees, a = 90, p = 360;\n        return 4*a/p * Math.abs((((x-p/4)%p)+p)%p - p/2) - a;\n    }\n\n    /**\n     * Constrain degrees to range -180..+180 (for longitude); e.g. -181 => 179, 181 => -179.\n     *\n     * @private\n     * @param {number} degrees\n     * @returns degrees within range -180..+180.\n     */\n    static wrap180(degrees) {\n        if (-180<=degrees && degrees<=180) return degrees; // avoid rounding due to arithmetic ops if within range\n\n        // longitude wrapping requires a sawtooth wave function; a general sawtooth wave is\n        //     f(x) = (2ax/p - p/2) % p - a\n        // where a = amplitude, p = period, % = modulo; however, JavaScript '%' is a remainder operator\n        // not a modulo operator - for modulo, replace 'x%n' with '((x%n)+n)%n'\n        const x = degrees, a = 180, p = 360;\n        return (((2*a*x/p - p/2)%p)+p)%p - a;\n    }\n\n    /**\n     * Constrain degrees to range 0..360 (for bearings); e.g. -1 => 359, 361 => 1.\n     *\n     * @private\n     * @param {number} degrees\n     * @returns degrees within range 0..360.\n     */\n    static wrap360(degrees) {\n        if (0<=degrees && degrees<360) return degrees; // avoid rounding due to arithmetic ops if within range\n\n        // bearing wrapping requires a sawtooth wave function with a vertical offset equal to the\n        // amplitude and a corresponding phase shift; this changes the general sawtooth wave function from\n        //     f(x) = (2ax/p - p/2) % p - a\n        // to\n        //     f(x) = (2ax/p) % p\n        // where a = amplitude, p = period, % = modulo; however, JavaScript '%' is a remainder operator\n        // not a modulo operator - for modulo, replace 'x%n' with '((x%n)+n)%n'\n        const x = degrees, a = 180, p = 360;\n        return (((2*a*x/p)%p)+p)%p;\n    }\n\n}\n\n\n// Extend Number object with methods to convert between degrees & radians\nNumber.prototype.toRadians = function() { return this * Math.PI / 180; };\nNumber.prototype.toDegrees = function() { return this * 180 / Math.PI; };\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nexport default Dms;\n","/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/* Vector handling functions                                          (c) Chris Veness 2011-2019  */\n/*                                                                                   MIT Licence  */\n/* www.movable-type.co.uk/scripts/geodesy-library.html#vector3d                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n\n/**\n * Library of 3-d vector manipulation routines.\n *\n * @module vector3d\n */\n\n\n/* Vector3d - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n\n/**\n * Functions for manipulating generic 3-d vectors.\n *\n * Functions return vectors as return results, so that operations can be chained.\n *\n * @example\n *   const v = v1.cross(v2).dot(v3) // ≡ v1×v2⋅v3\n */\nclass Vector3d {\n\n    /**\n     * Creates a 3-d vector.\n     *\n     * @param {number} x - X component of vector.\n     * @param {number} y - Y component of vector.\n     * @param {number} z - Z component of vector.\n     *\n     * @example\n     *   import Vector3d from '/js/geodesy/vector3d.js';\n     *   const v = new Vector3d(0.267, 0.535, 0.802);\n     */\n    constructor(x, y, z) {\n        if (isNaN(x) || isNaN(y) || isNaN(z)) throw new TypeError(`invalid vector [${x},${y},${z}]`);\n\n        this.x = Number(x);\n        this.y = Number(y);\n        this.z = Number(z);\n    }\n\n\n    /**\n     * Length (magnitude or norm) of ‘this’ vector.\n     *\n     * @returns {number} Magnitude of this vector.\n     */\n    get length() {\n        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n    }\n\n\n    /**\n     * Adds supplied vector to ‘this’ vector.\n     *\n     * @param   {Vector3d} v - Vector to be added to this vector.\n     * @returns {Vector3d} Vector representing sum of this and v.\n     */\n    plus(v) {\n        if (!(v instanceof Vector3d)) throw new TypeError('v is not Vector3d object');\n\n        return new Vector3d(this.x + v.x, this.y + v.y, this.z + v.z);\n    }\n\n\n    /**\n     * Subtracts supplied vector from ‘this’ vector.\n     *\n     * @param   {Vector3d} v - Vector to be subtracted from this vector.\n     * @returns {Vector3d} Vector representing difference between this and v.\n     */\n    minus(v) {\n        if (!(v instanceof Vector3d)) throw new TypeError('v is not Vector3d object');\n\n        return new Vector3d(this.x - v.x, this.y - v.y, this.z - v.z);\n    }\n\n\n    /**\n     * Multiplies ‘this’ vector by a scalar value.\n     *\n     * @param   {number}   x - Factor to multiply this vector by.\n     * @returns {Vector3d} Vector scaled by x.\n     */\n    times(x) {\n        if (isNaN(x)) throw new TypeError(`invalid scalar value ‘${x}’`);\n\n        return new Vector3d(this.x * x, this.y * x, this.z * x);\n    }\n\n\n    /**\n     * Divides ‘this’ vector by a scalar value.\n     *\n     * @param   {number}   x - Factor to divide this vector by.\n     * @returns {Vector3d} Vector divided by x.\n     */\n    dividedBy(x) {\n        if (isNaN(x)) throw new TypeError(`invalid scalar value ‘${x}’`);\n\n        return new Vector3d(this.x / x, this.y / x, this.z / x);\n    }\n\n\n    /**\n     * Multiplies ‘this’ vector by the supplied vector using dot (scalar) product.\n     *\n     * @param   {Vector3d} v - Vector to be dotted with this vector.\n     * @returns {number}   Dot product of ‘this’ and v.\n     */\n    dot(v) {\n        if (!(v instanceof Vector3d)) throw new TypeError('v is not Vector3d object');\n\n        return this.x * v.x + this.y * v.y + this.z * v.z;\n    }\n\n\n    /**\n     * Multiplies ‘this’ vector by the supplied vector using cross (vector) product.\n     *\n     * @param   {Vector3d} v - Vector to be crossed with this vector.\n     * @returns {Vector3d} Cross product of ‘this’ and v.\n     */\n    cross(v) {\n        if (!(v instanceof Vector3d)) throw new TypeError('v is not Vector3d object');\n\n        const x = this.y * v.z - this.z * v.y;\n        const y = this.z * v.x - this.x * v.z;\n        const z = this.x * v.y - this.y * v.x;\n\n        return new Vector3d(x, y, z);\n    }\n\n\n    /**\n     * Negates a vector to point in the opposite direction.\n     *\n     * @returns {Vector3d} Negated vector.\n     */\n    negate() {\n        return new Vector3d(-this.x, -this.y, -this.z);\n    }\n\n\n    /**\n     * Normalizes a vector to its unit vector\n     * – if the vector is already unit or is zero magnitude, this is a no-op.\n     *\n     * @returns {Vector3d} Normalised version of this vector.\n     */\n    unit() {\n        const norm = this.length;\n        if (norm == 1) return this;\n        if (norm == 0) return this;\n\n        const x = this.x / norm;\n        const y = this.y / norm;\n        const z = this.z / norm;\n\n        return new Vector3d(x, y, z);\n    }\n\n\n    /**\n     * Calculates the angle between ‘this’ vector and supplied vector atan2(|p₁×p₂|, p₁·p₂) (or if\n     * (extra-planar) ‘n’ supplied then atan2(n·p₁×p₂, p₁·p₂).\n     *\n     * @param   {Vector3d} v - Vector whose angle is to be determined from ‘this’ vector.\n     * @param   {Vector3d} [n] - Plane normal: if supplied, angle is signed +ve if this->v is\n     *                     clockwise looking along n, -ve in opposite direction.\n     * @returns {number}   Angle (in radians) between this vector and supplied vector (in range 0..π\n     *                     if n not supplied, range -π..+π if n supplied).\n     */\n    angleTo(v, n=undefined) {\n        if (!(v instanceof Vector3d)) throw new TypeError('v is not Vector3d object');\n        if (!(n instanceof Vector3d || n == undefined)) throw new TypeError('n is not Vector3d object');\n\n        // q.v. stackoverflow.com/questions/14066933#answer-16544330, but n·p₁×p₂ is numerically\n        // ill-conditioned, so just calculate sign to apply to |p₁×p₂|\n\n        // if n·p₁×p₂ is -ve, negate |p₁×p₂|\n        const sign = n==undefined || this.cross(v).dot(n)>=0 ? 1 : -1;\n\n        const sinθ = this.cross(v).length * sign;\n        const cosθ = this.dot(v);\n\n        return Math.atan2(sinθ, cosθ);\n    }\n\n\n    /**\n     * Rotates ‘this’ point around an axis by a specified angle.\n     *\n     * @param   {Vector3d} axis - The axis being rotated around.\n     * @param   {number}   angle - The angle of rotation (in degrees).\n     * @returns {Vector3d} The rotated point.\n     */\n    rotateAround(axis, angle) {\n        if (!(axis instanceof Vector3d)) throw new TypeError('axis is not Vector3d object');\n\n        const θ = angle.toRadians();\n\n        // en.wikipedia.org/wiki/Rotation_matrix#Rotation_matrix_from_axis_and_angle\n        // en.wikipedia.org/wiki/Quaternions_and_spatial_rotation#Quaternion-derived_rotation_matrix\n        const p = this.unit();\n        const a = axis.unit();\n\n        const s = Math.sin(θ);\n        const c = Math.cos(θ);\n        const t = 1-c;\n        const x = a.x, y = a.y, z = a.z;\n\n        const r = [ // rotation matrix for rotation about supplied axis\n            [ t*x*x + c,   t*x*y - s*z, t*x*z + s*y ],\n            [ t*x*y + s*z, t*y*y + c,   t*y*z - s*x ],\n            [ t*x*z - s*y, t*y*z + s*x, t*z*z + c   ],\n        ];\n\n        // multiply r × p\n        const rp = [\n            r[0][0]*p.x + r[0][1]*p.y + r[0][2]*p.z,\n            r[1][0]*p.x + r[1][1]*p.y + r[1][2]*p.z,\n            r[2][0]*p.x + r[2][1]*p.y + r[2][2]*p.z,\n        ];\n        const p2 = new Vector3d(rp[0], rp[1], rp[2]);\n\n        return p2;\n        // qv en.wikipedia.org/wiki/Rodrigues'_rotation_formula...\n    }\n\n\n    /**\n     * String representation of vector.\n     *\n     * @param   {number} [dp=3] - Number of decimal places to be used.\n     * @returns {string} Vector represented as [x,y,z].\n     */\n    toString(dp=3) {\n        return `[${this.x.toFixed(dp)},${this.y.toFixed(dp)},${this.z.toFixed(dp)}]`;\n    }\n\n}\n\n\n// Extend Number object with methods to convert between degrees & radians\nNumber.prototype.toRadians = function() { return this * Math.PI / 180; };\nNumber.prototype.toDegrees = function() { return this * 180 / Math.PI; };\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nexport default Vector3d;\n","/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/* Geodesy tools for an ellipsoidal earth model                       (c) Chris Veness 2005-2022  */\n/*                                                                                   MIT Licence  */\n/* Core class for latlon-ellipsoidal-datum & latlon-ellipsoidal-referenceframe.                   */\n/*                                                                                                */\n/* www.movable-type.co.uk/scripts/latlong-convert-coords.html                                     */\n/* www.movable-type.co.uk/scripts/geodesy-library.html#latlon-ellipsoidal                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nimport Dms      from './dms.js';\nimport Vector3d from './vector3d.js';\n\n\n/**\n * A latitude/longitude point defines a geographic location on or above/below the earth’s surface,\n * measured in degrees from the equator & the International Reference Meridian and in metres above\n * the ellipsoid, and based on a given datum.\n *\n * As so much modern geodesy is based on WGS-84 (as used by GPS), this module includes WGS-84\n * ellipsoid parameters, and it has methods for converting geodetic (latitude/longitude) points to/from\n * geocentric cartesian points; the latlon-ellipsoidal-datum and latlon-ellipsoidal-referenceframe\n * modules provide transformation parameters for converting between historical datums and between\n * modern reference frames.\n *\n * This module is used for both trigonometric geodesy (eg latlon-ellipsoidal-vincenty) and n-vector\n * geodesy (eg latlon-nvector-ellipsoidal), and also for UTM/MGRS mapping.\n *\n * @module latlon-ellipsoidal\n */\n\n\n/*\n * Ellipsoid parameters; exposed through static getter below.\n *\n * The only ellipsoid defined is WGS84, for use in utm/mgrs, vincenty, nvector.\n */\nconst ellipsoids = {\n    WGS84: { a: 6378137, b: 6356752.314245, f: 1/298.257223563 },\n};\n\n\n/*\n * Datums; exposed through static getter below.\n *\n * The only datum defined is WGS84, for use in utm/mgrs, vincenty, nvector.\n */\nconst datums = {\n    WGS84: { ellipsoid: ellipsoids.WGS84 },\n};\n\n\n// freeze static properties\nObject.freeze(ellipsoids.WGS84);\nObject.freeze(datums.WGS84);\n\n\n/* LatLonEllipsoidal - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n\n/**\n * Latitude/longitude points on an ellipsoidal model earth, with ellipsoid parameters and methods\n * for converting points to/from cartesian (ECEF) coordinates.\n *\n * This is the core class, which will usually be used via LatLonEllipsoidal_Datum or\n * LatLonEllipsoidal_ReferenceFrame.\n */\nclass LatLonEllipsoidal {\n\n    /**\n     * Creates a geodetic latitude/longitude point on a (WGS84) ellipsoidal model earth.\n     *\n     * @param  {number} lat - Latitude (in degrees).\n     * @param  {number} lon - Longitude (in degrees).\n     * @param  {number} [height=0] - Height above ellipsoid in metres.\n     * @throws {TypeError} Invalid lat/lon/height.\n     *\n     * @example\n     *   import LatLon from '/js/geodesy/latlon-ellipsoidal.js';\n     *   const p = new LatLon(51.47788, -0.00147, 17);\n     */\n    constructor(lat, lon, height=0) {\n        if (isNaN(lat) || lat == null) throw new TypeError(`invalid lat ‘${lat}’`);\n        if (isNaN(lon) || lon == null) throw new TypeError(`invalid lon ‘${lon}’`);\n        if (isNaN(height) || height == null) throw new TypeError(`invalid height ‘${height}’`);\n\n        this._lat = Dms.wrap90(Number(lat));\n        this._lon = Dms.wrap180(Number(lon));\n        this._height = Number(height);\n    }\n\n\n    /**\n     * Latitude in degrees north from equator (including aliases lat, latitude): can be set as\n     * numeric or hexagesimal (deg-min-sec); returned as numeric.\n     */\n    get lat()       { return this._lat; }\n    get latitude()  { return this._lat; }\n    set lat(lat) {\n        this._lat = isNaN(lat) ? Dms.wrap90(Dms.parse(lat)) : Dms.wrap90(Number(lat));\n        if (isNaN(this._lat)) throw new TypeError(`invalid lat ‘${lat}’`);\n    }\n    set latitude(lat) {\n        this._lat = isNaN(lat) ? Dms.wrap90(Dms.parse(lat)) : Dms.wrap90(Number(lat));\n        if (isNaN(this._lat)) throw new TypeError(`invalid latitude ‘${lat}’`);\n    }\n\n    /**\n     * Longitude in degrees east from international reference meridian (including aliases lon, lng,\n     * longitude): can be set as numeric or hexagesimal (deg-min-sec); returned as numeric.\n     */\n    get lon()       { return this._lon; }\n    get lng()       { return this._lon; }\n    get longitude() { return this._lon; }\n    set lon(lon) {\n        this._lon = isNaN(lon) ? Dms.wrap180(Dms.parse(lon)) : Dms.wrap180(Number(lon));\n        if (isNaN(this._lon)) throw new TypeError(`invalid lon ‘${lon}’`);\n    }\n    set lng(lon) {\n        this._lon = isNaN(lon) ? Dms.wrap180(Dms.parse(lon)) : Dms.wrap180(Number(lon));\n        if (isNaN(this._lon)) throw new TypeError(`invalid lng ‘${lon}’`);\n    }\n    set longitude(lon) {\n        this._lon = isNaN(lon) ? Dms.wrap180(Dms.parse(lon)) : Dms.wrap180(Number(lon));\n        if (isNaN(this._lon)) throw new TypeError(`invalid longitude ‘${lon}’`);\n    }\n\n    /**\n     * Height in metres above ellipsoid.\n     */\n    get height()       { return this._height; }\n    set height(height) { this._height = Number(height); if (isNaN(this._height)) throw new TypeError(`invalid height ‘${height}’`); }\n\n\n    /**\n     * Datum.\n     *\n     * Note this is replicated within LatLonEllipsoidal in order that a LatLonEllipsoidal object can\n     * be monkey-patched to look like a LatLonEllipsoidal_Datum, for Vincenty calculations on\n     * different ellipsoids.\n     *\n     * @private\n     */\n    get datum()      { return this._datum; }\n    set datum(datum) { this._datum = datum; }\n\n\n    /**\n     * Ellipsoids with their parameters; this module only defines WGS84 parameters a = 6378137, b =\n     * 6356752.314245, f = 1/298.257223563.\n     *\n     * @example\n     *   const a = LatLon.ellipsoids.WGS84.a; // 6378137\n     */\n    static get ellipsoids() {\n        return ellipsoids;\n    }\n\n    /**\n     * Datums; this module only defines WGS84 datum, hence no datum transformations.\n     *\n     * @example\n     *   const a = LatLon.datums.WGS84.ellipsoid.a; // 6377563.396\n     */\n    static get datums() {\n        return datums;\n    }\n\n\n    /**\n     * Parses a latitude/longitude point from a variety of formats.\n     *\n     * Latitude & longitude (in degrees) can be supplied as two separate parameters, as a single\n     * comma-separated lat/lon string, or as a single object with { lat, lon } or GeoJSON properties.\n     *\n     * The latitude/longitude values may be numeric or strings; they may be signed decimal or\n     * deg-min-sec (hexagesimal) suffixed by compass direction (NSEW); a variety of separators are\n     * accepted. Examples -3.62, '3 37 12W', '3°37′12″W'.\n     *\n     * Thousands/decimal separators must be comma/dot; use Dms.fromLocale to convert locale-specific\n     * thousands/decimal separators.\n     *\n     * @param   {number|string|Object} lat|latlon - Latitude (in degrees), or comma-separated lat/lon, or lat/lon object.\n     * @param   {number}               [lon]      - Longitude (in degrees).\n     * @param   {number}               [height=0] - Height above ellipsoid in metres.\n     * @returns {LatLon} Latitude/longitude point on WGS84 ellipsoidal model earth.\n     * @throws  {TypeError} Invalid coordinate.\n     *\n     * @example\n     *   const p1 = LatLon.parse(51.47788, -0.00147);              // numeric pair\n     *   const p2 = LatLon.parse('51°28′40″N, 000°00′05″W', 17);   // dms string + height\n     *   const p3 = LatLon.parse({ lat: 52.205, lon: 0.119 }, 17); // { lat, lon } object numeric + height\n     */\n    static parse(...args) {\n        if (args.length == 0) throw new TypeError('invalid (empty) point');\n\n        let lat=undefined, lon=undefined, height=undefined;\n\n        // single { lat, lon } object\n        if (typeof args[0]=='object' && (args.length==1 || !isNaN(parseFloat(args[1])))) {\n            const ll = args[0];\n            if (ll.type == 'Point' && Array.isArray(ll.coordinates)) { // GeoJSON\n                [ lon, lat, height ] = ll.coordinates;\n                height = height || 0;\n            } else { // regular { lat, lon } object\n                if (ll.latitude  != undefined) lat = ll.latitude;\n                if (ll.lat       != undefined) lat = ll.lat;\n                if (ll.longitude != undefined) lon = ll.longitude;\n                if (ll.lng       != undefined) lon = ll.lng;\n                if (ll.lon       != undefined) lon = ll.lon;\n                if (ll.height    != undefined) height = ll.height;\n                lat = Dms.wrap90(Dms.parse(lat));\n                lon = Dms.wrap180(Dms.parse(lon));\n            }\n            if (args[1] != undefined) height = args[1];\n            if (isNaN(lat) || isNaN(lon)) throw new TypeError(`invalid point ‘${JSON.stringify(args[0])}’`);\n        }\n\n        // single comma-separated lat/lon\n        if (typeof args[0] == 'string' && args[0].split(',').length == 2) {\n            [ lat, lon ] = args[0].split(',');\n            lat = Dms.wrap90(Dms.parse(lat));\n            lon = Dms.wrap180(Dms.parse(lon));\n            height = args[1] || 0;\n            if (isNaN(lat) || isNaN(lon)) throw new TypeError(`invalid point ‘${args[0]}’`);\n        }\n\n        // regular (lat, lon) arguments\n        if (lat==undefined && lon==undefined) {\n            [ lat, lon ] = args;\n            lat = Dms.wrap90(Dms.parse(lat));\n            lon = Dms.wrap180(Dms.parse(lon));\n            height = args[2] || 0;\n            if (isNaN(lat) || isNaN(lon)) throw new TypeError(`invalid point ‘${args.toString()}’`);\n        }\n\n        return new this(lat, lon, height); // 'new this' as may return subclassed types\n    }\n\n\n    /**\n     * Converts ‘this’ point from (geodetic) latitude/longitude coordinates to (geocentric)\n     * cartesian (x/y/z) coordinates.\n     *\n     * @returns {Cartesian} Cartesian point equivalent to lat/lon point, with x, y, z in metres from\n     *   earth centre.\n     */\n    toCartesian() {\n        // x = (ν+h)⋅cosφ⋅cosλ, y = (ν+h)⋅cosφ⋅sinλ, z = (ν⋅(1-e²)+h)⋅sinφ\n        // where ν = a/√(1−e²⋅sinφ⋅sinφ), e² = (a²-b²)/a² or (better conditioned) 2⋅f-f²\n        const ellipsoid = this.datum\n            ? this.datum.ellipsoid\n            : this.referenceFrame ? this.referenceFrame.ellipsoid : ellipsoids.WGS84;\n\n        const φ = this.lat.toRadians();\n        const λ = this.lon.toRadians();\n        const h = this.height;\n        const { a, f } = ellipsoid;\n\n        const sinφ = Math.sin(φ), cosφ = Math.cos(φ);\n        const sinλ = Math.sin(λ), cosλ = Math.cos(λ);\n\n        const eSq = 2*f - f*f;                      // 1st eccentricity squared ≡ (a²-b²)/a²\n        const ν = a / Math.sqrt(1 - eSq*sinφ*sinφ); // radius of curvature in prime vertical\n\n        const x = (ν+h) * cosφ * cosλ;\n        const y = (ν+h) * cosφ * sinλ;\n        const z = (ν*(1-eSq)+h) * sinφ;\n\n        return new Cartesian(x, y, z);\n    }\n\n\n    /**\n     * Checks if another point is equal to ‘this’ point.\n     *\n     * @param   {LatLon} point - Point to be compared against this point.\n     * @returns {bool} True if points have identical latitude, longitude, height, and datum/referenceFrame.\n     * @throws  {TypeError} Invalid point.\n     *\n     * @example\n     *   const p1 = new LatLon(52.205, 0.119);\n     *   const p2 = new LatLon(52.205, 0.119);\n     *   const equal = p1.equals(p2); // true\n     */\n    equals(point) {\n        if (!(point instanceof LatLonEllipsoidal)) throw new TypeError(`invalid point ‘${point}’`);\n\n        if (Math.abs(this.lat - point.lat) > Number.EPSILON) return false;\n        if (Math.abs(this.lon - point.lon) > Number.EPSILON) return false;\n        if (Math.abs(this.height - point.height) > Number.EPSILON) return false;\n        if (this.datum != point.datum) return false;\n        if (this.referenceFrame != point.referenceFrame) return false;\n        if (this.epoch != point.epoch) return false;\n\n        return true;\n    }\n\n\n    /**\n     * Returns a string representation of ‘this’ point, formatted as degrees, degrees+minutes, or\n     * degrees+minutes+seconds.\n     *\n     * @param   {string} [format=d] - Format point as 'd', 'dm', 'dms', or 'n' for signed numeric.\n     * @param   {number} [dp=4|2|0] - Number of decimal places to use: default 4 for d, 2 for dm, 0 for dms.\n     * @param   {number} [dpHeight=null] - Number of decimal places to use for height; default is no height display.\n     * @returns {string} Comma-separated formatted latitude/longitude.\n     * @throws  {RangeError} Invalid format.\n     *\n     * @example\n     *   const greenwich = new LatLon(51.47788, -0.00147, 46);\n     *   const d = greenwich.toString();                        // 51.4779°N, 000.0015°W\n     *   const dms = greenwich.toString('dms', 2);              // 51°28′40″N, 000°00′05″W\n     *   const [lat, lon] = greenwich.toString('n').split(','); // 51.4779, -0.0015\n     *   const dmsh = greenwich.toString('dms', 0, 0);          // 51°28′40″N, 000°00′06″W +46m\n     */\n    toString(format='d', dp=undefined, dpHeight=null) {\n        // note: explicitly set dp to undefined for passing through to toLat/toLon\n        if (![ 'd', 'dm', 'dms', 'n' ].includes(format)) throw new RangeError(`invalid format ‘${format}’`);\n\n        const height = (this.height>=0 ? ' +' : ' ') + this.height.toFixed(dpHeight) + 'm';\n        if (format == 'n') { // signed numeric degrees\n            if (dp == undefined) dp = 4;\n            const lat = this.lat.toFixed(dp);\n            const lon = this.lon.toFixed(dp);\n            return `${lat}, ${lon}${dpHeight==null ? '' : height}`;\n        }\n\n        const lat = Dms.toLat(this.lat, format, dp);\n        const lon = Dms.toLon(this.lon, format, dp);\n\n        return `${lat}, ${lon}${dpHeight==null ? '' : height}`;\n    }\n\n}\n\n\n/* Cartesian  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n\n/**\n * ECEF (earth-centered earth-fixed) geocentric cartesian coordinates.\n *\n * @extends Vector3d\n */\nclass Cartesian extends Vector3d {\n\n    /**\n     * Creates cartesian coordinate representing ECEF (earth-centric earth-fixed) point.\n     *\n     * @param {number} x - X coordinate in metres (=> 0°N,0°E).\n     * @param {number} y - Y coordinate in metres (=> 0°N,90°E).\n     * @param {number} z - Z coordinate in metres (=> 90°N).\n     *\n     * @example\n     *   import { Cartesian } from '/js/geodesy/latlon-ellipsoidal.js';\n     *   const coord = new Cartesian(3980581.210, -111.159, 4966824.522);\n     */\n    constructor(x, y, z) {\n        super(x, y, z); // arguably redundant constructor, but specifies units & axes\n    }\n\n\n    /**\n     * Converts ‘this’ (geocentric) cartesian (x/y/z) coordinate to (geodetic) latitude/longitude\n     * point on specified ellipsoid.\n     *\n     * Uses Bowring’s (1985) formulation for μm precision in concise form; ‘The accuracy of geodetic\n     * latitude and height equations’, B R Bowring, Survey Review vol 28, 218, Oct 1985.\n     *\n     * @param   {LatLon.ellipsoids} [ellipsoid=WGS84] - Ellipsoid to use when converting point.\n     * @returns {LatLon} Latitude/longitude point defined by cartesian coordinates, on given ellipsoid.\n     * @throws  {TypeError} Invalid ellipsoid.\n     *\n     * @example\n     *   const c = new Cartesian(4027893.924, 307041.993, 4919474.294);\n     *   const p = c.toLatLon(); // 50.7978°N, 004.3592°E\n     */\n    toLatLon(ellipsoid=ellipsoids.WGS84) {\n        // note ellipsoid is available as a parameter for when toLatLon gets subclassed to\n        // Ellipsoidal_Datum / Ellipsoidal_Referenceframe.\n        if (!ellipsoid || !ellipsoid.a) throw new TypeError(`invalid ellipsoid ‘${ellipsoid}’`);\n\n        const { x, y, z } = this;\n        const { a, b, f } = ellipsoid;\n\n        const e2 = 2*f - f*f;           // 1st eccentricity squared ≡ (a²−b²)/a²\n        const ε2 = e2 / (1-e2);         // 2nd eccentricity squared ≡ (a²−b²)/b²\n        const p = Math.sqrt(x*x + y*y); // distance from minor axis\n        const R = Math.sqrt(p*p + z*z); // polar radius\n\n        // parametric latitude (Bowring eqn.17, replacing tanβ = z·a / p·b)\n        const tanβ = (b*z)/(a*p) * (1+ε2*b/R);\n        const sinβ = tanβ / Math.sqrt(1+tanβ*tanβ);\n        const cosβ = sinβ / tanβ;\n\n        // geodetic latitude (Bowring eqn.18: tanφ = z+ε²⋅b⋅sin³β / p−e²⋅cos³β)\n        const φ = isNaN(cosβ) ? 0 : Math.atan2(z + ε2*b*sinβ*sinβ*sinβ, p - e2*a*cosβ*cosβ*cosβ);\n\n        // longitude\n        const λ = Math.atan2(y, x);\n\n        // height above ellipsoid (Bowring eqn.7)\n        const sinφ = Math.sin(φ), cosφ = Math.cos(φ);\n        const ν = a / Math.sqrt(1-e2*sinφ*sinφ); // length of the normal terminated by the minor axis\n        const h = p*cosφ + z*sinφ - (a*a/ν);\n\n        const point = new LatLonEllipsoidal(φ.toDegrees(), λ.toDegrees(), h);\n\n        return point;\n    }\n\n\n    /**\n     * Returns a string representation of ‘this’ cartesian point.\n     *\n     * @param   {number} [dp=0] - Number of decimal places to use.\n     * @returns {string} Comma-separated latitude/longitude.\n     */\n    toString(dp=0) {\n        const x = this.x.toFixed(dp), y = this.y.toFixed(dp), z = this.z.toFixed(dp);\n        return `[${x},${y},${z}]`;\n    }\n\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nexport { LatLonEllipsoidal as default, Cartesian, Vector3d, Dms };\n","/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/* Geodesy tools for conversions between (historical) datums          (c) Chris Veness 2005-2019  */\n/*                                                                                   MIT Licence  */\n/* www.movable-type.co.uk/scripts/latlong-convert-coords.html                                     */\n/* www.movable-type.co.uk/scripts/geodesy-library.html#latlon-ellipsoidal-datum                  */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nimport LatLonEllipsoidal, { Cartesian, Dms } from './latlon-ellipsoidal.js';\n\n\n/**\n * Historical geodetic datums: a latitude/longitude point defines a geographic location on or\n * above/below the  earth’s surface, measured in degrees from the equator & the International\n * Reference Meridian and metres above the ellipsoid, and based on a given datum. The datum is\n * based on a reference ellipsoid and tied to geodetic survey reference points.\n *\n * Modern geodesy is generally based on the WGS84 datum (as used for instance by GPS systems), but\n * previously various reference ellipsoids and datum references were used.\n *\n * This module extends the core latlon-ellipsoidal module to include ellipsoid parameters and datum\n * transformation parameters, and methods for converting between different (generally historical)\n * datums.\n *\n * It can be used for UK Ordnance Survey mapping (OS National Grid References are still based on the\n * otherwise historical OSGB36 datum), as well as for historical purposes.\n *\n * q.v. Ordnance Survey ‘A guide to coordinate systems in Great Britain’ Section 6,\n * www.ordnancesurvey.co.uk/docs/support/guide-coordinate-systems-great-britain.pdf, and also\n * www.ordnancesurvey.co.uk/blog/2014/12/2.\n *\n * @module latlon-ellipsoidal-datum\n */\n\n\n/*\n * Ellipsoid parameters; exposed through static getter below.\n */\nconst ellipsoids = {\n    WGS84:         { a: 6378137,     b: 6356752.314245, f: 1/298.257223563 },\n    Airy1830:      { a: 6377563.396, b: 6356256.909,    f: 1/299.3249646   },\n    AiryModified:  { a: 6377340.189, b: 6356034.448,    f: 1/299.3249646   },\n    Bessel1841:    { a: 6377397.155, b: 6356078.962818, f: 1/299.1528128   },\n    Clarke1866:    { a: 6378206.4,   b: 6356583.8,      f: 1/294.978698214 },\n    Clarke1880IGN: { a: 6378249.2,   b: 6356515.0,      f: 1/293.466021294 },\n    GRS80:         { a: 6378137,     b: 6356752.314140, f: 1/298.257222101 },\n    Intl1924:      { a: 6378388,     b: 6356911.946,    f: 1/297           }, // aka Hayford\n    WGS72:         { a: 6378135,     b: 6356750.5,      f: 1/298.26        },\n};\n\n\n/*\n * Datums; exposed through static getter below.\n */\nconst datums = {\n    // transforms: t in metres, s in ppm, r in arcseconds              tx       ty        tz       s        rx        ry        rz\n    ED50:       { ellipsoid: ellipsoids.Intl1924,      transform: [   89.5,    93.8,    123.1,    -1.2,     0.0,      0.0,      0.156    ] }, // epsg.io/1311\n    ETRS89:     { ellipsoid: ellipsoids.GRS80,         transform: [    0,       0,        0,       0,       0,        0,        0        ] }, // epsg.io/1149; @ 1-metre level\n    Irl1975:    { ellipsoid: ellipsoids.AiryModified,  transform: [ -482.530, 130.596, -564.557,  -8.150,   1.042,    0.214,    0.631    ] }, // epsg.io/1954\n    NAD27:      { ellipsoid: ellipsoids.Clarke1866,    transform: [    8,    -160,     -176,       0,       0,        0,        0        ] },\n    NAD83:      { ellipsoid: ellipsoids.GRS80,         transform: [    0.9956, -1.9103,  -0.5215, -0.00062, 0.025915, 0.009426, 0.011599 ] },\n    NTF:        { ellipsoid: ellipsoids.Clarke1880IGN, transform: [  168,      60,     -320,       0,       0,        0,        0        ] },\n    OSGB36:     { ellipsoid: ellipsoids.Airy1830,      transform: [ -446.448, 125.157, -542.060,  20.4894, -0.1502,  -0.2470,  -0.8421   ] }, // epsg.io/1314\n    Potsdam:    { ellipsoid: ellipsoids.Bessel1841,    transform: [ -582,    -105,     -414,      -8.3,     1.04,     0.35,    -3.08     ] },\n    TokyoJapan: { ellipsoid: ellipsoids.Bessel1841,    transform: [  148,    -507,     -685,       0,       0,        0,        0        ] },\n    WGS72:      { ellipsoid: ellipsoids.WGS72,         transform: [    0,       0,       -4.5,    -0.22,    0,        0,        0.554    ] },\n    WGS84:      { ellipsoid: ellipsoids.WGS84,         transform: [    0.0,     0.0,      0.0,     0.0,     0.0,      0.0,      0.0      ] },\n};\n/* sources:\n * - ED50:       www.gov.uk/guidance/oil-and-gas-petroleum-operations-notices#pon-4\n * - Irl1975:    www.osi.ie/wp-content/uploads/2015/05/transformations_booklet.pdf\n * - NAD27:      en.wikipedia.org/wiki/Helmert_transformation\n * - NAD83:      www.uvm.edu/giv/resources/WGS84_NAD83.pdf [strictly, WGS84(G1150) -> NAD83(CORS96) @ epoch 1997.0]\n *               (note NAD83(1986) ≡ WGS84(Original); confluence.qps.nl/pages/viewpage.action?pageId=29855173)\n * - NTF:        Nouvelle Triangulation Francaise geodesie.ign.fr/contenu/fichiers/Changement_systeme_geodesique.pdf\n * - OSGB36:     www.ordnancesurvey.co.uk/docs/support/guide-coordinate-systems-great-britain.pdf\n * - Potsdam:    kartoweb.itc.nl/geometrics/Coordinate%20transformations/coordtrans.html\n * - TokyoJapan: www.geocachingtoolbox.com?page=datumEllipsoidDetails\n * - WGS72:      www.icao.int/safety/pbn/documentation/eurocontrol/eurocontrol wgs 84 implementation manual.pdf\n *\n * more transform parameters are available from earth-info.nga.mil/GandG/coordsys/datums/NATO_DT.pdf,\n * www.fieldenmaps.info/cconv/web/cconv_params.js\n */\n/* note:\n * - ETRS89 reference frames are coincident with WGS-84 at epoch 1989.0 (ie null transform) at the one metre level.\n */\n\n\n// freeze static properties\nObject.keys(ellipsoids).forEach(e => Object.freeze(ellipsoids[e]));\nObject.keys(datums).forEach(d => { Object.freeze(datums[d]); Object.freeze(datums[d].transform); });\n\n\n/* LatLon - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n\n/**\n * Latitude/longitude points on an ellipsoidal model earth, with ellipsoid parameters and methods\n * for converting between datums and to geocentric (ECEF) cartesian coordinates.\n *\n * @extends LatLonEllipsoidal\n */\nclass LatLonEllipsoidal_Datum extends LatLonEllipsoidal {\n\n    /**\n     * Creates a geodetic latitude/longitude point on an ellipsoidal model earth using given datum.\n     *\n     * @param {number} lat - Latitude (in degrees).\n     * @param {number} lon - Longitude (in degrees).\n     * @param {number} [height=0] - Height above ellipsoid in metres.\n     * @param {LatLon.datums} datum - Datum this point is defined within.\n     *\n     * @example\n     *   import LatLon from '/js/geodesy/latlon-ellipsoidal-datum.js';\n     *   const p = new LatLon(53.3444, -6.2577, 17, LatLon.datums.Irl1975);\n     */\n    constructor(lat, lon, height=0, datum=datums.WGS84) {\n        if (!datum || datum.ellipsoid==undefined) throw new TypeError(`unrecognised datum ‘${datum}’`);\n\n        super(lat, lon, height);\n\n        this._datum = datum;\n    }\n\n\n    /**\n     * Datum this point is defined within.\n     */\n    get datum() {\n        return this._datum;\n    }\n\n\n    /**\n     * Ellipsoids with their parameters; semi-major axis (a), semi-minor axis (b), and flattening (f).\n     *\n     * Flattening f = (a−b)/a; at least one of these parameters is derived from defining constants.\n     *\n     * @example\n     *   const a = LatLon.ellipsoids.Airy1830.a; // 6377563.396\n     */\n    static get ellipsoids() {\n        return ellipsoids;\n    }\n\n\n    /**\n     * Datums; with associated ellipsoid, and Helmert transform parameters to convert from WGS-84\n     * into given datum.\n     *\n     * Note that precision of various datums will vary, and WGS-84 (original) is not defined to be\n     * accurate to better than ±1 metre. No transformation should be assumed to be accurate to\n     * better than a metre, for many datums somewhat less.\n     *\n     * This is a small sample of commoner datums from a large set of historical datums. I will add\n     * new datums on request.\n     *\n     * @example\n     *   const a = LatLon.datums.OSGB36.ellipsoid.a;                    // 6377563.396\n     *   const tx = LatLon.datums.OSGB36.transform;                     // [ tx, ty, tz, s, rx, ry, rz ]\n     *   const availableDatums = Object.keys(LatLon.datums).join(', '); // ED50, Irl1975, NAD27, ...\n     */\n    static get datums() {\n        return datums;\n    }\n\n\n    // note instance datum getter/setters are in LatLonEllipsoidal\n\n\n    /**\n     * Parses a latitude/longitude point from a variety of formats.\n     *\n     * Latitude & longitude (in degrees) can be supplied as two separate parameters, as a single\n     * comma-separated lat/lon string, or as a single object with { lat, lon } or GeoJSON properties.\n     *\n     * The latitude/longitude values may be numeric or strings; they may be signed decimal or\n     * deg-min-sec (hexagesimal) suffixed by compass direction (NSEW); a variety of separators are\n     * accepted. Examples -3.62, '3 37 12W', '3°37′12″W'.\n     *\n     * Thousands/decimal separators must be comma/dot; use Dms.fromLocale to convert locale-specific\n     * thousands/decimal separators.\n     *\n     * @param   {number|string|Object} lat|latlon - Geodetic Latitude (in degrees) or comma-separated lat/lon or lat/lon object.\n     * @param   {number}               [lon] - Longitude in degrees.\n     * @param   {number}               [height=0] - Height above ellipsoid in metres.\n     * @param   {LatLon.datums}        [datum=WGS84] - Datum this point is defined within.\n     * @returns {LatLon} Latitude/longitude point on ellipsoidal model earth using given datum.\n     * @throws  {TypeError} Unrecognised datum.\n     *\n     * @example\n     *   const p = LatLon.parse('51.47736, 0.0000', 0, LatLon.datums.OSGB36);\n     */\n    static parse(...args) {\n        let datum = datums.WGS84;\n\n        // if the last argument is a datum, use that, otherwise use default WGS-84\n        if (args.length==4 || (args.length==3 && typeof args[2] == 'object')) datum = args.pop();\n\n        if (!datum || datum.ellipsoid==undefined) throw new TypeError(`unrecognised datum ‘${datum}’`);\n\n        const point = super.parse(...args);\n\n        point._datum = datum;\n\n        return point;\n    }\n\n\n    /**\n     * Converts ‘this’ lat/lon coordinate to new coordinate system.\n     *\n     * @param   {LatLon.datums} toDatum - Datum this coordinate is to be converted to.\n     * @returns {LatLon} This point converted to new datum.\n     * @throws  {TypeError} Unrecognised datum.\n     *\n     * @example\n     *   const pWGS84 = new LatLon(51.47788, -0.00147, 0, LatLon.datums.WGS84);\n     *   const pOSGB = pWGS84.convertDatum(LatLon.datums.OSGB36); // 51.4773°N, 000.0001°E\n     */\n    convertDatum(toDatum) {\n        if (!toDatum || toDatum.ellipsoid==undefined) throw new TypeError(`unrecognised datum ‘${toDatum}’`);\n\n        const oldCartesian = this.toCartesian();                 // convert geodetic to cartesian\n        const newCartesian = oldCartesian.convertDatum(toDatum); // convert datum\n        const newLatLon = newCartesian.toLatLon();               // convert cartesian back to geodetic\n\n        return newLatLon;\n    }\n\n\n    /**\n     * Converts ‘this’ point from (geodetic) latitude/longitude coordinates to (geocentric) cartesian\n     * (x/y/z) coordinates, based on the same datum.\n     *\n     * Shadow of LatLonEllipsoidal.toCartesian(), returning Cartesian augmented with\n     * LatLonEllipsoidal_Datum methods/properties.\n     *\n     * @returns {Cartesian} Cartesian point equivalent to lat/lon point, with x, y, z in metres from\n     *   earth centre, augmented with reference frame conversion methods and properties.\n     */\n    toCartesian() {\n        const cartesian = super.toCartesian();\n        const cartesianDatum = new Cartesian_Datum(cartesian.x, cartesian.y, cartesian.z, this.datum);\n        return cartesianDatum;\n    }\n\n}\n\n\n/* Cartesian  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n\n/**\n * Augments Cartesian with datum the cooordinate is based on, and methods to convert between datums\n * (using Helmert 7-parameter transforms) and to convert cartesian to geodetic latitude/longitude\n * point.\n *\n * @extends Cartesian\n */\nclass Cartesian_Datum extends Cartesian {\n\n    /**\n     * Creates cartesian coordinate representing ECEF (earth-centric earth-fixed) point, on a given\n     * datum. The datum will identify the primary meridian (for the x-coordinate), and is also\n     * useful in transforming to/from geodetic (lat/lon) coordinates.\n     *\n     * @param  {number} x - X coordinate in metres (=> 0°N,0°E).\n     * @param  {number} y - Y coordinate in metres (=> 0°N,90°E).\n     * @param  {number} z - Z coordinate in metres (=> 90°N).\n     * @param  {LatLon.datums} [datum] - Datum this coordinate is defined within.\n     * @throws {TypeError} Unrecognised datum.\n     *\n     * @example\n     *   import { Cartesian } from '/js/geodesy/latlon-ellipsoidal-datum.js';\n     *   const coord = new Cartesian(3980581.210, -111.159, 4966824.522);\n     */\n    constructor(x, y, z, datum=undefined) {\n        if (datum && datum.ellipsoid==undefined) throw new TypeError(`unrecognised datum ‘${datum}’`);\n\n        super(x, y, z);\n\n        if (datum) this._datum = datum;\n    }\n\n\n    /**\n     * Datum this point is defined within.\n     */\n    get datum() {\n        return this._datum;\n    }\n    set datum(datum) {\n        if (!datum || datum.ellipsoid==undefined) throw new TypeError(`unrecognised datum ‘${datum}’`);\n        this._datum = datum;\n    }\n\n\n    /**\n     * Converts ‘this’ (geocentric) cartesian (x/y/z) coordinate to (geodetic) latitude/longitude\n     * point (based on the same datum, or WGS84 if unset).\n     *\n     * Shadow of Cartesian.toLatLon(), returning LatLon augmented with LatLonEllipsoidal_Datum\n     * methods convertDatum, toCartesian, etc.\n     *\n     * @returns {LatLon} Latitude/longitude point defined by cartesian coordinates.\n     * @throws  {TypeError} Unrecognised datum\n     *\n     * @example\n     *   const c = new Cartesian(4027893.924, 307041.993, 4919474.294);\n     *   const p = c.toLatLon(); // 50.7978°N, 004.3592°E\n     */\n    toLatLon(deprecatedDatum=undefined) {\n        if (deprecatedDatum) {\n            console.info('datum parameter to Cartesian_Datum.toLatLon is deprecated: set datum before calling toLatLon()');\n            this.datum = deprecatedDatum;\n        }\n        const datum = this.datum || datums.WGS84;\n        if (!datum || datum.ellipsoid==undefined) throw new TypeError(`unrecognised datum ‘${datum}’`);\n\n        const latLon = super.toLatLon(datum.ellipsoid); // TODO: what if datum is not geocentric?\n        const point = new LatLonEllipsoidal_Datum(latLon.lat, latLon.lon, latLon.height, this.datum);\n        return point;\n    }\n\n\n    /**\n     * Converts ‘this’ cartesian coordinate to new datum using Helmert 7-parameter transformation.\n     *\n     * @param   {LatLon.datums} toDatum - Datum this coordinate is to be converted to.\n     * @returns {Cartesian} This point converted to new datum.\n     * @throws  {Error} Undefined datum.\n     *\n     * @example\n     *   const c = new Cartesian(3980574.247, -102.127, 4966830.065, LatLon.datums.OSGB36);\n     *   c.convertDatum(LatLon.datums.Irl1975); // [??,??,??]\n     */\n    convertDatum(toDatum) {\n        // TODO: what if datum is not geocentric?\n        if (!toDatum || toDatum.ellipsoid == undefined) throw new TypeError(`unrecognised datum ‘${toDatum}’`);\n        if (!this.datum) throw new TypeError('cartesian coordinate has no datum');\n\n        let oldCartesian = null;\n        let transform = null;\n\n        if (this.datum == undefined || this.datum == datums.WGS84) {\n            // converting from WGS 84\n            oldCartesian = this;\n            transform = toDatum.transform;\n        }\n        if (toDatum == datums.WGS84) {\n            // converting to WGS 84; use inverse transform\n            oldCartesian = this;\n            transform = this.datum.transform.map(p => -p);\n        }\n        if (transform == null) {\n            // neither this.datum nor toDatum are WGS84: convert this to WGS84 first\n            oldCartesian = this.convertDatum(datums.WGS84);\n            transform = toDatum.transform;\n        }\n\n        const newCartesian = oldCartesian.applyTransform(transform);\n        newCartesian.datum = toDatum;\n\n        return newCartesian;\n    }\n\n\n    /**\n     * Applies Helmert 7-parameter transformation to ‘this’ coordinate using transform parameters t.\n     *\n     * This is used in converting datums (geodetic->cartesian, apply transform, cartesian->geodetic).\n     *\n     * @private\n     * @param   {number[]} t - Transformation to apply to this coordinate.\n     * @returns {Cartesian} Transformed point.\n     */\n    applyTransform(t)   {\n        // this point\n        const { x: x1, y: y1, z: z1 } = this;\n\n        // transform parameters\n        const tx = t[0];                    // x-shift in metres\n        const ty = t[1];                    // y-shift in metres\n        const tz = t[2];                    // z-shift in metres\n        const s  = t[3]/1e6 + 1;            // scale: normalise parts-per-million to (s+1)\n        const rx = (t[4]/3600).toRadians(); // x-rotation: normalise arcseconds to radians\n        const ry = (t[5]/3600).toRadians(); // y-rotation: normalise arcseconds to radians\n        const rz = (t[6]/3600).toRadians(); // z-rotation: normalise arcseconds to radians\n\n        // apply transform\n        const x2 = tx + x1*s  - y1*rz + z1*ry;\n        const y2 = ty + x1*rz + y1*s  - z1*rx;\n        const z2 = tz - x1*ry + y1*rx + z1*s;\n\n        return new Cartesian_Datum(x2, y2, z2);\n    }\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nexport { LatLonEllipsoidal_Datum as default, Cartesian_Datum as Cartesian, datums, Dms };\n","/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/* Ordnance Survey Grid Reference functions                           (c) Chris Veness 2005-2021  */\n/*                                                                                   MIT Licence  */\n/* www.movable-type.co.uk/scripts/latlong-gridref.html                                            */\n/* www.movable-type.co.uk/scripts/geodesy-library.html#osgridref                                  */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nimport LatLonEllipsoidal, { Dms } from './latlon-ellipsoidal-datum.js';\n\n\n/**\n * Ordnance Survey OSGB grid references provide geocoordinate references for UK mapping purposes.\n *\n * Formulation implemented here due to Thomas, Redfearn, etc is as published by OS, but is inferior\n * to Krüger as used by e.g. Karney 2011.\n *\n * www.ordnancesurvey.co.uk/documents/resources/guide-coordinate-systems-great-britain.pdf.\n *\n * Note OSGB grid references cover Great Britain only; Ireland and the Channel Islands have their\n * own references.\n *\n * Note that these formulae are based on ellipsoidal calculations, and according to the OS are\n * accurate to about 4–5 metres – for greater accuracy, a geoid-based transformation (OSTN15) must\n * be used.\n */\n\n/*\n * Converted 2015 to work with WGS84 by default, OSGB36 as option;\n * www.ordnancesurvey.co.uk/blog/2014/12/confirmation-on-changes-to-latitude-and-longitude\n */\n\n\n/* OsGridRef  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n\nconst nationalGrid = {\n    trueOrigin:  { lat: 49, lon: -2 },                 // true origin of grid 49°N,2°W on OSGB36 datum\n    falseOrigin: { easting: -400e3, northing: 100e3 }, // easting & northing of false origin, metres from true origin\n    scaleFactor: 0.9996012717,                         // scale factor on central meridian\n    ellipsoid:   LatLonEllipsoidal.ellipsoids.Airy1830,\n};\n// note Irish National Grid uses t/o 53°30′N, 8°W, f/o 200kmW, 250kmS, scale factor 1.000035, on Airy 1830 Modified ellipsoid\n\n\n/**\n * OS Grid References with methods to parse and convert them to latitude/longitude points.\n */\nclass OsGridRef {\n\n    /**\n     * Creates an OsGridRef object.\n     *\n     * @param {number} easting - Easting in metres from OS Grid false origin.\n     * @param {number} northing - Northing in metres from OS Grid false origin.\n     *\n     * @example\n     *   import OsGridRef from '/js/geodesy/osgridref.js';\n     *   const gridref = new OsGridRef(651409, 313177);\n     */\n    constructor(easting, northing) {\n        this.easting = Number(easting);\n        this.northing = Number(northing);\n\n        if (isNaN(easting)  || this.easting<0  || this.easting>700e3) throw new RangeError(`invalid easting ‘${easting}’`);\n        if (isNaN(northing) || this.northing<0 || this.northing>1300e3) throw new RangeError(`invalid northing ‘${northing}’`);\n    }\n\n\n    /**\n     * Converts ‘this’ Ordnance Survey Grid Reference easting/northing coordinate to latitude/longitude\n     * (SW corner of grid square).\n     *\n     * While OS Grid References are based on OSGB-36, the Ordnance Survey have deprecated the use of\n     * OSGB-36 for latitude/longitude coordinates (in favour of WGS-84), hence this function returns\n     * WGS-84 by default, with OSGB-36 as an option. See www.ordnancesurvey.co.uk/blog/2014/12/2.\n     *\n     * Note formulation implemented here due to Thomas, Redfearn, etc is as published by OS, but is\n     * inferior to Krüger as used by e.g. Karney 2011.\n     *\n     * @param   {LatLon.datum} [datum=WGS84] - Datum to convert grid reference into.\n     * @returns {LatLon}       Latitude/longitude of supplied grid reference.\n     *\n     * @example\n     *   const gridref = new OsGridRef(651409.903, 313177.270);\n     *   const pWgs84 = gridref.toLatLon();                    // 52°39′28.723″N, 001°42′57.787″E\n     *   // to obtain (historical) OSGB36 lat/lon point:\n     *   const pOsgb = gridref.toLatLon(LatLon.datums.OSGB36); // 52°39′27.253″N, 001°43′04.518″E\n     */\n    toLatLon(datum=LatLonEllipsoidal.datums.WGS84) {\n        const { easting: E, northing: N } = this;\n\n        const { a, b } = nationalGrid.ellipsoid;            // a = 6377563.396, b = 6356256.909\n        const φ0 = nationalGrid.trueOrigin.lat.toRadians(); // latitude of true origin, 49°N\n        const λ0 = nationalGrid.trueOrigin.lon.toRadians(); // longitude of true origin, 2°W\n        const E0 = -nationalGrid.falseOrigin.easting;       // easting of true origin, 400km\n        const N0 = -nationalGrid.falseOrigin.northing;      // northing of true origin, -100km\n        const F0 = nationalGrid.scaleFactor;                // 0.9996012717\n\n        const e2 = 1 - (b*b)/(a*a);                         // eccentricity squared\n        const n = (a-b)/(a+b), n2 = n*n, n3 = n*n*n;        // n, n², n³\n\n        let φ=φ0, M=0;\n        do {\n            φ = (N-N0-M)/(a*F0) + φ;\n\n            const Ma = (1 + n + (5/4)*n2 + (5/4)*n3) * (φ-φ0);\n            const Mb = (3*n + 3*n*n + (21/8)*n3) * Math.sin(φ-φ0) * Math.cos(φ+φ0);\n            const Mc = ((15/8)*n2 + (15/8)*n3) * Math.sin(2*(φ-φ0)) * Math.cos(2*(φ+φ0));\n            const Md = (35/24)*n3 * Math.sin(3*(φ-φ0)) * Math.cos(3*(φ+φ0));\n            M = b * F0 * (Ma - Mb + Mc - Md);                // meridional arc\n\n        } while (Math.abs(N-N0-M) >= 0.00001);  // ie until < 0.01mm\n\n        const cosφ = Math.cos(φ), sinφ = Math.sin(φ);\n        const ν = a*F0/Math.sqrt(1-e2*sinφ*sinφ);            // nu = transverse radius of curvature\n        const ρ = a*F0*(1-e2)/Math.pow(1-e2*sinφ*sinφ, 1.5); // rho = meridional radius of curvature\n        const η2 = ν/ρ-1;                                    // eta = ?\n\n        const tanφ = Math.tan(φ);\n        const tan2φ = tanφ*tanφ, tan4φ = tan2φ*tan2φ, tan6φ = tan4φ*tan2φ;\n        const secφ = 1/cosφ;\n        const ν3 = ν*ν*ν, ν5 = ν3*ν*ν, ν7 = ν5*ν*ν;\n        const VII = tanφ/(2*ρ*ν);\n        const VIII = tanφ/(24*ρ*ν3)*(5+3*tan2φ+η2-9*tan2φ*η2);\n        const IX = tanφ/(720*ρ*ν5)*(61+90*tan2φ+45*tan4φ);\n        const X = secφ/ν;\n        const XI = secφ/(6*ν3)*(ν/ρ+2*tan2φ);\n        const XII = secφ/(120*ν5)*(5+28*tan2φ+24*tan4φ);\n        const XIIA = secφ/(5040*ν7)*(61+662*tan2φ+1320*tan4φ+720*tan6φ);\n\n        const dE = (E-E0), dE2 = dE*dE, dE3 = dE2*dE, dE4 = dE2*dE2, dE5 = dE3*dE2, dE6 = dE4*dE2, dE7 = dE5*dE2;\n        φ = φ - VII*dE2 + VIII*dE4 - IX*dE6;\n        const λ = λ0 + X*dE - XI*dE3 + XII*dE5 - XIIA*dE7;\n\n        let point = new LatLon_OsGridRef(φ.toDegrees(), λ.toDegrees(), 0, LatLonEllipsoidal.datums.OSGB36);\n\n        if (datum != LatLonEllipsoidal.datums.OSGB36) {\n            // if point is required in datum other than OSGB36, convert it\n            point = point.convertDatum(datum);\n            // convertDatum() gives us a LatLon: convert to LatLon_OsGridRef which includes toOsGrid()\n            point = new LatLon_OsGridRef(point.lat, point.lon, point.height, point.datum);\n        }\n\n        return point;\n    }\n\n\n    /**\n     * Parses grid reference to OsGridRef object.\n     *\n     * Accepts standard grid references (eg 'SU 387 148'), with or without whitespace separators, from\n     * two-digit references up to 10-digit references (1m × 1m square), or fully numeric comma-separated\n     * references in metres (eg '438700,114800').\n     *\n     * @param   {string}    gridref - Standard format OS Grid Reference.\n     * @returns {OsGridRef} Numeric version of grid reference in metres from false origin (SW corner of\n     *   supplied grid square).\n     * @throws  {Error}     Invalid grid reference.\n     *\n     * @example\n     *   const grid = OsGridRef.parse('TG 51409 13177'); // grid: { easting: 651409, northing: 313177 }\n     */\n    static parse(gridref) {\n        gridref = String(gridref).trim();\n\n        // check for fully numeric comma-separated gridref format\n        let match = gridref.match(/^(\\d+),\\s*(\\d+)$/);\n        if (match) return new OsGridRef(match[1], match[2]);\n\n        // validate format\n        match = gridref.match(/^[HNST][ABCDEFGHJKLMNOPQRSTUVWXYZ]\\s*[0-9]+\\s*[0-9]+$/i);\n        if (!match) throw new Error(`invalid grid reference ‘${gridref}’`);\n\n        // get numeric values of letter references, mapping A->0, B->1, C->2, etc:\n        let l1 = gridref.toUpperCase().charCodeAt(0) - 'A'.charCodeAt(0); // 500km square\n        let l2 = gridref.toUpperCase().charCodeAt(1) - 'A'.charCodeAt(0); // 100km square\n        // shuffle down letters after 'I' since 'I' is not used in grid:\n        if (l1 > 7) l1--;\n        if (l2 > 7) l2--;\n\n        // convert grid letters into 100km-square indexes from false origin (grid square SV):\n        const e100km = ((l1 - 2) % 5) * 5 + (l2 % 5);\n        const n100km = (19 - Math.floor(l1 / 5) * 5) - Math.floor(l2 / 5);\n\n        // skip grid letters to get numeric (easting/northing) part of ref\n        let en = gridref.slice(2).trim().split(/\\s+/);\n        // if e/n not whitespace separated, split half way\n        if (en.length == 1) en = [ en[0].slice(0, en[0].length / 2), en[0].slice(en[0].length / 2) ];\n\n        // validation\n        if (en[0].length != en[1].length) throw new Error(`invalid grid reference ‘${gridref}’`);\n\n        // standardise to 10-digit refs (metres)\n        en[0] = en[0].padEnd(5, '0');\n        en[1] = en[1].padEnd(5, '0');\n\n        const e = e100km + en[0];\n        const n = n100km + en[1];\n\n        return new OsGridRef(e, n);\n    }\n\n\n    /**\n     * Converts ‘this’ numeric grid reference to standard OS Grid Reference.\n     *\n     * @param   {number} [digits=10] - Precision of returned grid reference (10 digits = metres);\n     *   digits=0 will return grid reference in numeric format.\n     * @returns {string} This grid reference in standard format.\n     *\n     * @example\n     *   const gridref = new OsGridRef(651409, 313177).toString(8); // 'TG 5140 1317'\n     *   const gridref = new OsGridRef(651409, 313177).toString(0); // '651409,313177'\n     */\n    toString(digits=10) {\n        if (![ 0,2,4,6,8,10,12,14,16 ].includes(Number(digits))) throw new RangeError(`invalid precision ‘${digits}’`); // eslint-disable-line comma-spacing\n\n        let { easting: e, northing: n } = this;\n\n        // use digits = 0 to return numeric format (in metres) - note northing may be >= 1e7\n        if (digits == 0) {\n            const format = { useGrouping: false,  minimumIntegerDigits: 6, maximumFractionDigits: 3 };\n            const ePad = e.toLocaleString('en', format);\n            const nPad = n.toLocaleString('en', format);\n            return `${ePad},${nPad}`;\n        }\n\n        // get the 100km-grid indices\n        const e100km = Math.floor(e / 100000), n100km = Math.floor(n / 100000);\n\n        // translate those into numeric equivalents of the grid letters\n        let l1 = (19 - n100km) - (19 - n100km) % 5 + Math.floor((e100km + 10) / 5);\n        let l2 = (19 - n100km) * 5 % 25 + e100km % 5;\n\n        // compensate for skipped 'I' and build grid letter-pairs\n        if (l1 > 7) l1++;\n        if (l2 > 7) l2++;\n        const letterPair = String.fromCharCode(l1 + 'A'.charCodeAt(0), l2 + 'A'.charCodeAt(0));\n\n        // strip 100km-grid indices from easting & northing, and reduce precision\n        e = Math.floor((e % 100000) / Math.pow(10, 5 - digits / 2));\n        n = Math.floor((n % 100000) / Math.pow(10, 5 - digits / 2));\n\n        // pad eastings & northings with leading zeros\n        e = e.toString().padStart(digits/2, '0');\n        n = n.toString().padStart(digits/2, '0');\n\n        return `${letterPair} ${e} ${n}`;\n    }\n\n}\n\n\n/* LatLon_OsGridRef - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n\n/**\n * Extends LatLon class with method to convert LatLon point to OS Grid Reference.\n *\n * @extends LatLonEllipsoidal\n */\nclass LatLon_OsGridRef extends LatLonEllipsoidal {\n\n    /**\n     * Converts latitude/longitude to Ordnance Survey grid reference easting/northing coordinate.\n     *\n     * @returns {OsGridRef} OS Grid Reference easting/northing.\n     *\n     * @example\n     *   const grid = new LatLon(52.65798, 1.71605).toOsGrid(); // TG 51409 13177\n     *   // for conversion of (historical) OSGB36 latitude/longitude point:\n     *   const grid = new LatLon(52.65798, 1.71605).toOsGrid(LatLon.datums.OSGB36);\n     */\n    toOsGrid() {\n        // if necessary convert to OSGB36 first\n        const point = this.datum == LatLonEllipsoidal.datums.OSGB36\n            ? this\n            : this.convertDatum(LatLonEllipsoidal.datums.OSGB36);\n\n        const φ = point.lat.toRadians();\n        const λ = point.lon.toRadians();\n\n        const { a, b } = nationalGrid.ellipsoid;            // a = 6377563.396, b = 6356256.909\n        const φ0 = nationalGrid.trueOrigin.lat.toRadians(); // latitude of true origin, 49°N\n        const λ0 = nationalGrid.trueOrigin.lon.toRadians(); // longitude of true origin, 2°W\n        const E0 = -nationalGrid.falseOrigin.easting;       // easting of true origin, 400km\n        const N0 = -nationalGrid.falseOrigin.northing;      // northing of true origin, -100km\n        const F0 = nationalGrid.scaleFactor;                // 0.9996012717\n\n        const e2 = 1 - (b*b)/(a*a);                          // eccentricity squared\n        const n = (a-b)/(a+b), n2 = n*n, n3 = n*n*n;         // n, n², n³\n\n        const cosφ = Math.cos(φ), sinφ = Math.sin(φ);\n        const ν = a*F0/Math.sqrt(1-e2*sinφ*sinφ);            // nu = transverse radius of curvature\n        const ρ = a*F0*(1-e2)/Math.pow(1-e2*sinφ*sinφ, 1.5); // rho = meridional radius of curvature\n        const η2 = ν/ρ-1;                                    // eta = ?\n\n        const Ma = (1 + n + (5/4)*n2 + (5/4)*n3) * (φ-φ0);\n        const Mb = (3*n + 3*n*n + (21/8)*n3) * Math.sin(φ-φ0) * Math.cos(φ+φ0);\n        const Mc = ((15/8)*n2 + (15/8)*n3) * Math.sin(2*(φ-φ0)) * Math.cos(2*(φ+φ0));\n        const Md = (35/24)*n3 * Math.sin(3*(φ-φ0)) * Math.cos(3*(φ+φ0));\n        const M = b * F0 * (Ma - Mb + Mc - Md);              // meridional arc\n\n        const cos3φ = cosφ*cosφ*cosφ;\n        const cos5φ = cos3φ*cosφ*cosφ;\n        const tan2φ = Math.tan(φ)*Math.tan(φ);\n        const tan4φ = tan2φ*tan2φ;\n\n        const I = M + N0;\n        const II = (ν/2)*sinφ*cosφ;\n        const III = (ν/24)*sinφ*cos3φ*(5-tan2φ+9*η2);\n        const IIIA = (ν/720)*sinφ*cos5φ*(61-58*tan2φ+tan4φ);\n        const IV = ν*cosφ;\n        const V = (ν/6)*cos3φ*(ν/ρ-tan2φ);\n        const VI = (ν/120) * cos5φ * (5 - 18*tan2φ + tan4φ + 14*η2 - 58*tan2φ*η2);\n\n        const Δλ = λ-λ0;\n        const Δλ2 = Δλ*Δλ, Δλ3 = Δλ2*Δλ, Δλ4 = Δλ3*Δλ, Δλ5 = Δλ4*Δλ, Δλ6 = Δλ5*Δλ;\n\n        let N = I + II*Δλ2 + III*Δλ4 + IIIA*Δλ6;\n        let E = E0 + IV*Δλ + V*Δλ3 + VI*Δλ5;\n\n        N = Number(N.toFixed(3)); // round to mm precision\n        E = Number(E.toFixed(3));\n\n        try {\n            return new OsGridRef(E, N); // note: gets truncated to SW corner of 1m grid square\n        } catch (e) {\n            throw new Error(`${e.message} from (${point.lat.toFixed(6)},${point.lon.toFixed(6)}).toOsGrid()`);\n        }\n    }\n\n\n    /**\n     * Override LatLonEllipsoidal.convertDatum() with version which returns LatLon_OsGridRef.\n     */\n    convertDatum(toDatum) {\n        const osgbED = super.convertDatum(toDatum); // returns LatLonEllipsoidal_Datum\n        const osgbOSGR = new LatLon_OsGridRef(osgbED.lat, osgbED.lon, osgbED.height, osgbED.datum);\n        return osgbOSGR;\n    }\n\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nexport { OsGridRef as default, LatLon_OsGridRef as LatLon, Dms };\n"],"names":["_regeneratorRuntime","e","t","r","Object","prototype","n","hasOwnProperty","o","defineProperty","value","i","Symbol","a","iterator","c","asyncIterator","u","toStringTag","define","enumerable","configurable","writable","wrap","Generator","create","Context","makeInvokeMethod","tryCatch","type","arg","call","h","l","f","s","y","GeneratorFunction","GeneratorFunctionPrototype","p","d","getPrototypeOf","v","values","g","defineIteratorMethods","forEach","_invoke","AsyncIterator","invoke","_typeof","resolve","__await","then","callInvokeWithMethodAndArg","Error","done","method","delegate","maybeInvokeDelegate","sent","_sent","dispatchException","abrupt","return","TypeError","resultName","next","nextLoc","pushTryEntry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","isNaN","length","displayName","isGeneratorFunction","constructor","name","mark","setPrototypeOf","__proto__","awrap","async","Promise","keys","reverse","pop","prev","charAt","slice","stop","rval","handle","complete","finish","catch","delegateYield","asyncGeneratorStep","_asyncToGenerator","arguments","apply","_next","_throw","_toConsumableArray","Array","isArray","_arrayLikeToArray","_arrayWithoutHoles","from","_iterableToArray","toString","test","_unsupportedIterableToArray","_nonIterableSpread","removeNonEngland","results","filter","GAZETTEER_ENTRY","COUNTRY","toLowerCase","removeDuplicates","Map","map","result","ID","removeTenuousResults","query","words","replace","split","some","w","NAME1","includes","markString","string","find","patterns","Set","concat","trim","join","reg","RegExp","__html","suggestion","_ref2","COUNTY_UNITARY","DISTRICT_BOROUGH","POSTCODE_DISTRICT","LOCAL_TYPE","qualifier","text","id","marked","parseResults","_ref3","_callee","transformGeocodeRequest","url","response","json","_context","config","encodeURI","t0","fetch","t1","error","header","totalresults","t2","console","log","_x","_x2","Geocode","undefined","_classCallCheck","this","key","_suggest","_callee2","_context2","_x3","_find","_callee3","_context3","MBR_XMIN","MBR_YMIN","MBR_XMAX","MBR_YMAX","GEOMETRY_X","GEOMETRY_Y","_ref","bounds","OsGridRef","toLatLon","lon","lat","Math","round","center","_x4","dmsSeparator","Dms","separator","char","parse","dms","parseFloat","isFinite","Number","dmsParts","String","splice","NaN","deg","toDms","format","dp","Infinity","abs","m","toFixed","floor","toLat","wrap90","toLon","wrap180","toBrng","brng","wrap360","fromLocale","str","locale","toLocaleString","thousands","decimal","toLocale","compassPoint","bearing","precision","RangeError","degrees","x","toRadians","PI","toDegrees","Vector3d","z","sqrt","plus","minus","times","dividedBy","dot","cross","negate","unit","norm","angleTo","sign","atan2","rotateAround","axis","angle","sin","cos","rp","ellipsoids","WGS84","b","datums","ellipsoid","freeze","LatLonEllipsoidal","height","_lat","_lon","_height","latitude","lng","longitude","datum","_datum","args","ll","coordinates","JSON","stringify","toCartesian","referenceFrame","eSq","Cartesian","equals","point","EPSILON","epoch","dpHeight","super","e2","Airy1830","AiryModified","Bessel1841","Clarke1866","Clarke1880IGN","GRS80","Intl1924","WGS72","ED50","transform","ETRS89","Irl1975","NAD27","NAD83","NTF","OSGB36","Potsdam","TokyoJapan","LatLonEllipsoidal_Datum","convertDatum","toDatum","cartesian","Cartesian_Datum","deprecatedDatum","info","latLon","oldCartesian","newCartesian","applyTransform","x1","y1","z1","tx","ty","tz","rx","ry","rz","nationalGrid","trueOrigin","falseOrigin","easting","northing","scaleFactor","E","N","E0","N0","F0","n2","n3","M","pow","tan","dE","dE2","dE3","dE4","dE5","LatLon_OsGridRef","gridref","match","l1","toUpperCase","charCodeAt","l2","e100km","n100km","en","padEnd","digits","useGrouping","minimumIntegerDigits","maximumFractionDigits","letterPair","fromCharCode","padStart","toOsGrid","message","osgbED"],"sourceRoot":""}