"use strict";(self.webpackChunk_defra_flood_map=self.webpackChunk_defra_flood_map||[]).push([[2031,4461],{"./node_modules/@arcgis/core/chunks/GeometryCleaner-BEJM7I4l.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{c:()=>i});var _Geometry_js__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/@arcgis/core/chunks/Geometry.js");function i(i,a){const f=i.getGeometryType();return f===_Geometry_js__WEBPACK_IMPORTED_MODULE_0__.G.enumPoint?i:(0,_Geometry_js__WEBPACK_IMPORTED_MODULE_0__.h)(f)?u(i):f===_Geometry_js__WEBPACK_IMPORTED_MODULE_0__.G.enumMultiPoint||f===_Geometry_js__WEBPACK_IMPORTED_MODULE_0__.G.enumEnvelope?i:f===_Geometry_js__WEBPACK_IMPORTED_MODULE_0__.G.enumMultipatch?((0,_Geometry_js__WEBPACK_IMPORTED_MODULE_0__.b)("not implemented for multipatch"),i):i}function u(e){if(function a(e){for(let n=0,i=e.getPathCount();n<i;n++){const i=e.getPathSize(n);if(0===i)return!1;if(1===i){if(0===e.getSegmentCountPath(n))return!1;if(e.getSegmentType(e.getPathStart(n))===_Geometry_js__WEBPACK_IMPORTED_MODULE_0__.G.enumLine)return!1;if(!e.isClosedPath(n))return!1}}return!0}(e))return e;const n=e.createInstance();for(let i=0,r=e.getPathCount();i<r;i++){const r=e.getPathSize(i);if(0!==r){if(1===r){if(0===e.getSegmentCountPath(i))continue;if(e.getSegmentType(e.getPathStart(i))===_Geometry_js__WEBPACK_IMPORTED_MODULE_0__.G.enumLine)continue;if(!e.isClosedPath(i))continue}n.addPath(e,i,!0)}}return n}},"./node_modules/@arcgis/core/chunks/OperatorGeneralize.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{O:()=>P});var _tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/@arcgis/core/chunks/tslib.es6.js"),_SimpleGeometryCursor_js__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/@arcgis/core/chunks/SimpleGeometryCursor.js"),_Geometry_js__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/@arcgis/core/chunks/Geometry.js"),_QuadraticBezier_js__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__("./node_modules/@arcgis/core/chunks/QuadraticBezier.js"),_Envelope_js__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__("./node_modules/@arcgis/core/chunks/Envelope.js"),_Point2D_js__WEBPACK_IMPORTED_MODULE_5__=__webpack_require__("./node_modules/@arcgis/core/chunks/Point2D.js"),_OperatorDensify_js__WEBPACK_IMPORTED_MODULE_6__=__webpack_require__("./node_modules/@arcgis/core/chunks/OperatorDensify.js");class P{getOperatorType(){return 10204}supportsCurves(){return!0}accelerateGeometry(t,e,s){return!1}canAccelerateGeometry(t){return!1}executeMany(t,e,s,i){return new y(t,e,s,i)}execute(t,e,s,r){return t||(0,_Geometry_js__WEBPACK_IMPORTED_MODULE_2__.t)("null param is not allowed."),new y(null,e,s,r).generalize(t)}}class y extends _SimpleGeometryCursor_js__WEBPACK_IMPORTED_MODULE_1__.G{constructor(t,e,s,i){super(),this.m_pline=null,this.m_point=new _Envelope_js__WEBPACK_IMPORTED_MODULE_4__.P,this.m_stack=[],this.m_resultstack=[],this.m_callCount=0,this.m_progressTracker=i,this.m_geoms=t,this.m_maxDeviation=e,this.m_bRemoveDegenerateParts=s}tock(){return!0}getRank(){return 1}next(){const t=this.m_geoms.next();return null===t?null:((0,_Geometry_js__WEBPACK_IMPORTED_MODULE_2__.d)(t),this.generalize(t))}getGeometryID(){return this.m_geoms.getGeometryID()}generalize(s){const i=s.getGeometryType();if((0,_Geometry_js__WEBPACK_IMPORTED_MODULE_2__.e)(i))return s;if(i===_Geometry_js__WEBPACK_IMPORTED_MODULE_2__.G.enumEnvelope){const t=new _QuadraticBezier_js__WEBPACK_IMPORTED_MODULE_3__.a({vd:s.getDescription()});return t.addEnvelope(s,!1),this.generalize(t)}if((0,_Geometry_js__WEBPACK_IMPORTED_MODULE_2__.f)(i)){const t=new _QuadraticBezier_js__WEBPACK_IMPORTED_MODULE_3__.P({vd:s.getDescription()});return t.addSegment(s,!0),this.generalize(t)}if((0,_Geometry_js__WEBPACK_IMPORTED_MODULE_2__.h)(i)||(0,_Geometry_js__WEBPACK_IMPORTED_MODULE_2__.b)(""),s.isEmpty()||this.m_maxDeviation<=0)return s;const r=(new _OperatorDensify_js__WEBPACK_IMPORTED_MODULE_6__.O).execute(s,0,.05*this.m_maxDeviation,0,this.m_progressTracker);s.hasNonLinearSegments()&&(this.m_maxDeviation*=.95);const _=r,p=s.createInstance();p.getGeometryType()===_Geometry_js__WEBPACK_IMPORTED_MODULE_2__.G.enumPolygon&&p.setFillRule(s.getFillRule()),this.m_xy=_.getAttributeStreamRef(0);{const s={stack:[],error:void 0,hasError:!1};try{const e=new _QuadraticBezier_js__WEBPACK_IMPORTED_MODULE_3__.L;this.m_pline=e,(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.b)(s,(0,_Point2D_js__WEBPACK_IMPORTED_MODULE_5__.h)((()=>{this.m_pline=null}),!1),!1);for(let t=0,s=_.getPathCount();t<s;t++)this.generalizePath(_.getImpl(),t,p.getImpl())}catch(k){s.error=k,s.hasError=!0}finally{(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.c)(s)}}return this.m_resultstack.length=0,this.m_stack.length=0,p}generalizePath(t,e,s){if(t.getPathSize(e)<2)return;this.m_resultstack.length=0,this.m_stack.length=0;const i=t.getPathStart(e),r=t.getPathEnd(e)-1,a=t.isClosedPath(e),n=t.isClosedPathInXYPlane(e);let h=0,m=-1;this.m_stack.push(a?i:r),this.m_stack.push(i);let l=!1,o=!1;for(!this.m_bRemoveDegenerateParts&&n&&(l=!0,o=!0);this.m_stack.length>1;){const e=this.m_stack.at(-1);this.m_stack.pop();const s=this.m_stack.at(-1);let i=t.getXY(e);this.m_pline.setStartXY(i),i=t.getXY(s),this.m_pline.setEndXY(i);const a=[Number.NaN];let n=this.findGreatestDistance(e,s,r,a);n>=0&&(l?l=!1:(o&&a[0]>h&&(h=a[0],m=n),a[0]<=this.m_maxDeviation&&(n=-1))),n>=0?(this.m_stack.push(n),this.m_stack.push(e)):this.m_resultstack.push(e)}a||this.m_resultstack.push(this.m_stack[0]);const c=this.m_resultstack.length;if(c===t.getPathSize(e)&&c===this.m_stack.length)s.addPath(t,e,!0);else if(this.m_resultstack.length>0){if(this.m_bRemoveDegenerateParts&&this.m_resultstack.length<=2){if(a||1===this.m_resultstack.length)return;if(_Point2D_js__WEBPACK_IMPORTED_MODULE_5__.P.distance(t.getXY(this.m_resultstack[0]),t.getXY(this.m_resultstack[1]))<=this.m_maxDeviation)return}if(o&&m>=0&&h<=this.m_maxDeviation){const t=this.m_resultstack.at(-1)>m;this.m_resultstack.push(m),t&&(this.m_resultstack[this.m_resultstack.length-2]=(0,_Point2D_js__WEBPACK_IMPORTED_MODULE_5__.b)(this.m_resultstack[this.m_resultstack.length-1],this.m_resultstack[this.m_resultstack.length-1]=this.m_resultstack[this.m_resultstack.length-2]))}for(let e=0,i=this.m_resultstack.length;e<i;e++)t.getPointByVal(this.m_resultstack[e],this.m_point),0===e?s.startPathPoint(this.m_point):s.lineToPoint(this.m_point);if(a){for(let t=this.m_resultstack.length;t<3;t++)s.lineToPoint(this.m_point);s.closePathWithLine()}}}findGreatestDistance(t,e,s,i){let r=e-1;e<=t&&(r=s);let a=-1,n=0;const h=new _Point2D_js__WEBPACK_IMPORTED_MODULE_5__.P;for(let m=t+1;m<=r;m++){this.m_xy.queryPoint2D(2*m,h);const t=h.x,e=h.y,s=this.m_pline.getClosestCoordinate(h,!1);h.assign(this.m_pline.getCoord2D(s)),h.x-=t,h.y-=e;const i=h.length();i>n&&(a=m,n=i),this.m_callCount++}return i[0]=n,a}}},"./node_modules/@arcgis/core/chunks/SimpleGeometryCursor.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{G:()=>t,S:()=>s});class t{*[Symbol.iterator](){let t=this.next();for(;t;)yield t,t=this.next()}}class s extends t{constructor(t){super(),this.m_iGeom=-1,this.m_aGeoms=t?t.slice():[]}next(){if(this.m_iGeom<this.m_aGeoms.length-1){const t=this.m_aGeoms[++this.m_iGeom];return this.m_aGeoms[this.m_iGeom]=null,t}return null}tock(){return!1}getGeometryID(){return this.m_iGeom}getRank(){return 1}}},"./node_modules/@arcgis/core/geometry/operators/gx/operatorBuffer.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{g7:()=>f,yv:()=>l,fz:()=>x});var O,SimpleGeometryCursor=__webpack_require__("./node_modules/@arcgis/core/chunks/SimpleGeometryCursor.js"),Geometry=__webpack_require__("./node_modules/@arcgis/core/chunks/Geometry.js"),ProjectionTransformation=__webpack_require__("./node_modules/@arcgis/core/chunks/ProjectionTransformation.js"),Envelope2D=__webpack_require__("./node_modules/@arcgis/core/chunks/Envelope2D.js"),tslib_es6=__webpack_require__("./node_modules/@arcgis/core/chunks/tslib.es6.js"),Envelope=__webpack_require__("./node_modules/@arcgis/core/chunks/Envelope.js"),Point2D=__webpack_require__("./node_modules/@arcgis/core/chunks/Point2D.js"),QuadraticBezier=__webpack_require__("./node_modules/@arcgis/core/chunks/QuadraticBezier.js"),Transformation2D=__webpack_require__("./node_modules/@arcgis/core/chunks/Transformation2D.js"),GeometryCleaner_BEJM7I4l=__webpack_require__("./node_modules/@arcgis/core/chunks/GeometryCleaner-BEJM7I4l.js"),OperatorGeneralize=__webpack_require__("./node_modules/@arcgis/core/chunks/OperatorGeneralize.js");class L{getOperatorType(){return 10104}accelerateGeometry(e,t,s){return!1}canAccelerateGeometry(e){return!1}supportsCurves(){return!0}isSimple(e,t,s,i,n){return 5===(0,ProjectionTransformation.aj)(e,t,s,i,n)}executeMany(e,t,s,i){return new N(e,t,s,i)}execute(e,t,i,n){const r=new SimpleGeometryCursor.S([e]),m=this.executeMany(r,t,i,n).next();return m||(0,Geometry.c)("null output"),m}}class N extends SimpleGeometryCursor.G{constructor(e,t,s,n){super(),e||(0,Geometry.t)(""),this.m_progressTracker=n,this.m_bForceSimplify=s,this.m_index=-1,this.m_inputGeometryCursor=e,this.m_spatialReference=t}next(){const e=this.m_inputGeometryCursor.next();return e?((0,Geometry.d)(e),this.m_index=this.m_inputGeometryCursor.getGeometryID(),this.simplify(e)):null}getGeometryID(){return this.m_index}tock(){return!1}getRank(){return 1}simplify(e){return e||(0,Geometry.t)(""),(0,ProjectionTransformation.ak)(e,this.m_spatialReference,this.m_bForceSimplify,this.m_progressTracker)}}function J(e,t,s,i,n,r){return{m_from:e.clone(),m_to:t.clone(),m_center:s.clone(),m_next:n,m_type:i}}function U(e,t,s,i,n){return{m_from:e.clone(),m_to:t.clone(),m_next:s,m_type:4,m_center:new Point2D.P}}!function(e){e[e.enumDummy=256]="enumDummy",e[e.enumLine=1]="enumLine",e[e.enumArc=2]="enumArc",e[e.enumMiter=8]="enumMiter",e[e.enumBevel=16]="enumBevel",e[e.enumJoinMask=26]="enumJoinMask",e[e.enumConnectionMask=27]="enumConnectionMask"}(O||(O={}));class Q extends SimpleGeometryCursor.G{constructor(e,t,s,i,n,r,m,o,a,h){super(),this.m_index=0,this.m_bufferedPolygon=null,this.m_x=0,this.m_y=0,this.m_progressTracker=h,this.m_parent=e,this.m_mp=t,this.m_distance=s,this.m_spatialReference=i,this.m_densifyDist=o,this.m_maxVertexInCompleteCircle=a,this.m_joins=n,this.m_caps=r,this.m_miterLimit=m}next(){const e=new Envelope.P;for(;;){if(this.m_index===this.m_mp.getPointCount())return null;if(1===this.m_caps)return this.m_index=this.m_mp.getPointCount(),new QuadraticBezier.a({vd:this.m_mp.getDescription()});if(this.m_mp.getPointByVal(this.m_index,e),this.m_index++,!e.isEmpty())break}let t,s=!1;if(null===this.m_bufferedPolygon&&(this.m_x=e.getX(),this.m_y=e.getY(),this.m_bufferedPolygon=this.m_parent.buffer(e,this.m_distance,this.m_spatialReference,this.m_joins,this.m_caps,this.m_miterLimit,this.m_densifyDist,this.m_maxVertexInCompleteCircle),s=!0),t=this.m_index<this.m_mp.getPointCount()?this.m_bufferedPolygon.clone():this.m_bufferedPolygon,!s){const s=new Transformation2D.T,i=e.getX()-this.m_x,n=e.getY()-this.m_y;s.setShiftCoords(i,n),t.applyTransformation(s)}return(0,Envelope.s)(t,0),t}getGeometryID(){return 0}getRank(){return 1}tock(){return!0}}class H extends SimpleGeometryCursor.G{constructor(e){super(),this.m_currentPathIndex=0,this.m_polyline=e}next(){if(!this.m_polyline)return null;const e=this.m_polyline.getImpl(),t=e.getPathCount();if(this.m_currentPathIndex<t){const t=this.m_currentPathIndex;if(this.m_currentPathIndex++,!e.isClosedPathInXYPlane(t)){let s=e.getXY(e.getPathEnd(t)-1);for(;this.m_currentPathIndex<e.getPathCount();){const t=e.getXY(e.getPathStart(this.m_currentPathIndex));if(e.isClosedPathInXYPlane(this.m_currentPathIndex))break;if(!t.equals(s))break;s=e.getXY(e.getPathEnd(this.m_currentPathIndex)-1),this.m_currentPathIndex++}}if(0===t&&this.m_currentPathIndex===this.m_polyline.getPathCount()){const e=this.m_polyline;return this.m_polyline=null,e}const s=new QuadraticBezier.P({vd:this.m_polyline.getDescription()});s.addPath(this.m_polyline,t,!0);for(let i=t+1;i<this.m_currentPathIndex;i++)s.addSegmentsFromPath(this.m_polyline,i,0,e.getSegmentCountPath(i),!1);return this.m_currentPathIndex===this.m_polyline.getPathCount()&&(this.m_polyline=null),s}return null}getGeometryID(){return 0}getRank(){return 1}tock(){return!0}}class K extends SimpleGeometryCursor.G{constructor(e,t,s){super(),this.m_geometry=null,this.m_index=0,this.m_bufferer=e,this.m_geoms=t,this.m_index=0,this.m_bFilter=s}next(){if(null===this.m_geometry&&(this.m_index=0,this.m_geometry=this.m_geoms.next(),!this.m_geometry))return null;const e=this.m_geometry.getImpl();if(this.m_index<e.getPathCount()){const e=this.m_index;return this.m_index++,this.m_bufferer.bufferPolylinePath(this.m_geometry,e,this.m_bFilter)}return this.m_geometry=null,this.next()}getGeometryID(){return 0}getRank(){return 1}tock(){return!0}}class W extends SimpleGeometryCursor.G{constructor(e){super(),this.m_index=0,this.m_bufferer=e}next(){const e=this.m_bufferer.m_geometry;if(this.m_index<e.getPathCount()){const t=this.m_index,s=e.calculateRingArea2D(this.m_index);for((0,Geometry.g)(s>0),this.m_index++;this.m_index<e.getPathCount()&&!(e.calculateRingArea2D(this.m_index)>0);)this.m_index++;let i;return i=0===t&&this.m_index===e.getPathCount()?this.m_bufferer.bufferPolygonImpl(e,0,e.getPathCount()):this.m_bufferer.bufferPolygonImpl(e,t,this.m_index),i}return null}getGeometryID(){return 0}getRank(){return 1}tock(){return!0}}class Z{constructor(e){this.m_geometry=null,this.m_bufferCommands=[],this.m_originalGeomType=Geometry.G.enumUnknown,this.m_maxVertexInCompleteCircle=-1,this.m_circleTemplateSize=-1,this.m_oldCircleTemplateSize=0,this.m_spatialReference=null,this.m_tolerance=new Envelope.C(0,0),this.m_smallTolerance=new Envelope.C(0,0),this.m_filterTolerance=0,this.m_densifyDist=-1,this.m_distance=Number.NaN,this.m_absDistance=0,this.m_absDistanceReversed=0,this.m_dA=-1,this.m_miterLimit=4,this.m_joins=0,this.m_caps=0,this.m_bRoundBuffer=!0,this.m_bOutputLoops=!0,this.m_bFilter=!0,this.m_circleTemplate=[],this.m_leftStack=[],this.m_middleStack=[],this.m_helperLine1=new QuadraticBezier.L,this.m_helperLine2=new QuadraticBezier.L,this.m_helperArray=[],this.m_progressCounter=0,this.m_densificator=QuadraticBezier.D.constructDefault(e),this.m_progressTracker=e}buffer(e,t,s,n,r,u,f,_){if(e||(0,Geometry.t)("Geometry.Bufferer.Impl.Buffer"),f<0&&(0,Geometry.t)("Geometry.Bufferer.Impl.Buffer"),(0,Geometry.o)(e.getGeometryType())&&(0,Geometry.b)("Unsupported geometry type."),e.isEmpty())return new QuadraticBezier.a({vd:e.getDescription()});if(this.m_joins=n,this.m_caps=r,this.m_bRoundBuffer=!1,this.m_miterLimit=u,this.m_originalGeomType=e.getGeometryType(),(0,Geometry.p)(this.m_originalGeomType)?this.m_bRoundBuffer=0===this.m_joins:(0,Geometry.e)(this.m_originalGeomType)?this.m_bRoundBuffer=0===this.m_caps:(0,Geometry.q)(this.m_originalGeomType)&&(this.m_bRoundBuffer=0===this.m_joins&&0===this.m_caps),this.m_bFilter=this.m_bRoundBuffer,this.m_geometry=(0,GeometryCleaner_BEJM7I4l.c)(e),this.m_geometry.isEmpty())return new QuadraticBezier.a({vd:e.getDescription()});const g=new Envelope2D.J;this.m_geometry.queryLooseEnvelope(g),t>0&&g.inflateCoords(t,t),this.m_tolerance=(0,Envelope.a)(s,g,!0),this.m_smallTolerance=(0,Envelope.a)(null,g,!0),_<=0&&(_=96),this.m_spatialReference=s,this.m_distance=t,this.m_absDistance=Math.abs(this.m_distance),this.m_absDistanceReversed=0!==this.m_absDistance?1/this.m_absDistance:0,Number.isNaN(f)||0===f?f=1e-5*this.m_absDistance:f>.5*this.m_absDistance&&(f=.5*this.m_absDistance),_<12&&(_=12);const d=Math.abs(t)*(1-Math.cos(Math.PI/_));if(d>f)f=d;else if(0!==t){const e=Math.PI/Math.acos(1-f/Math.abs(t));e<_-1&&(_=Math.trunc(e))<12&&(_=12,f=Math.abs(t)*(1-Math.cos(Math.PI/_)))}this.m_densifyDist=f,this.m_maxVertexInCompleteCircle=_,this.m_filterTolerance=this.m_bRoundBuffer?Math.min(this.m_smallTolerance.total(),.25*this.m_densifyDist):0,this.m_circleTemplateSize=this.calcN(),this.m_circleTemplateSize!==this.m_oldCircleTemplateSize&&(this.m_circleTemplate.length=0,this.m_oldCircleTemplateSize=this.m_circleTemplateSize),this.m_densifyDist>0&&(0,Geometry.j)(this.m_geometry)&&(this.m_geometry=this.m_densificator.densifyEx(this.m_geometry,0,this.m_densifyDist,0,0!==this.m_joins,(0,Point2D.i)()));const y=this.bufferImpl();return this.m_geometry=null,y}generateCircleTemplate(){if(this.m_circleTemplate.length)return;const e=this.m_circleTemplateSize,t=Math.trunc((e+3)/4),s=.5*Math.PI/t;this.m_dA=s,this.m_circleTemplate=(0,Point2D.m)(Point2D.P,4*t);const i=Math.cos(s),n=Math.sin(s),r=Point2D.P.construct(0,1);for(let m=0;m<t;m++)this.m_circleTemplate[m+0*t].setCoords(r.y,-r.x),this.m_circleTemplate[m+1*t].setCoords(-r.x,-r.y),this.m_circleTemplate[m+2*t].setCoords(-r.y,r.x),this.m_circleTemplate[m+3*t].setCoords(r.x,r.y),r.rotateReverse(i,n)}bufferImpl(){const e=this.m_geometry.getGeometryType();if((0,Geometry.f)(e)){const e=new QuadraticBezier.P({vd:this.m_geometry.getDescription()});return e.addSegment(this.m_geometry,!0),this.m_geometry=e,this.bufferImpl()}if(this.m_distance<=this.m_tolerance.total()){if(!(0,Geometry.p)(e))return new QuadraticBezier.a({vd:this.m_geometry.getDescription()});if(this.m_distance<0){const e=new Envelope2D.J;if(this.m_geometry.queryEnvelope(e),e.width()<=2*this.m_absDistance||e.height()<=2*this.m_absDistance)return new QuadraticBezier.a({vd:this.m_geometry.getDescription()})}}switch(this.m_geometry.getGeometryType()){case Geometry.G.enumPoint:return this.bufferPoint();case Geometry.G.enumMultiPoint:return this.bufferMultiPoint();case Geometry.G.enumPolyline:return this.bufferPolyline();case Geometry.G.enumPolygon:return this.bufferPolygon();case Geometry.G.enumEnvelope:return this.bufferEnvelope();default:(0,Geometry.c)("")}}bufferPolyline(){if(this.isDegenerateGeometry(this.m_geometry)){const e=new Envelope.P;this.m_geometry.getPointByVal(0,e);const t=new Envelope2D.J;return this.m_geometry.queryEnvelope(t),e.setXY(t.getCenter()),this.bufferDegeneratePath(e,!0)}const e=this.m_geometry,t=this.m_geometry.getDescription();this.m_geometry=null;const s=new H(e);let i,n;i=0===this.m_joins?(new OperatorGeneralize.O).executeMany(s,.25*this.m_densifyDist,!1,this.m_progressTracker):s,n=this.m_bRoundBuffer?(new L).executeMany(i,null,!0,this.m_progressTracker):i;const r=new K(this,n,this.m_bFilter),m=(new ProjectionTransformation.h).executeMany(r,this.m_spatialReference,this.m_progressTracker,2),o=(new ProjectionTransformation.g).executeMany(m,this.m_spatialReference,!1,this.m_progressTracker).next();return null!==o?o:new QuadraticBezier.a({vd:t})}bufferPolygon(){if(0===this.m_distance)return this.m_geometry;this.generateCircleTemplate();const e=(new ProjectionTransformation.g).execute(this.m_geometry,null,!1,this.m_progressTracker);if(this.m_distance<0){if(this.m_geometry=e,this.m_geometry.isEmpty())return this.m_geometry;const t=this.m_geometry,s=this.bufferPolygonImpl(t,0,t.getPathCount());return(new ProjectionTransformation.g).execute(s,this.m_spatialReference,!1,this.m_progressTracker)}{if(this.m_geometry=e,this.isDegenerateGeometry(this.m_geometry)){const e=new Envelope.P;this.m_geometry.getPointByVal(0,e);const t=new Envelope2D.J;return this.m_geometry.queryEnvelope(t),e.setXY(t.getCenter()),this.bufferDegeneratePath(e,!0)}const t=new W(this),s=(new ProjectionTransformation.h).executeMany(t,this.m_spatialReference,this.m_progressTracker,2),i=(new ProjectionTransformation.g).executeMany(s,this.m_spatialReference,!1,this.m_progressTracker).next();return null!==i?i:new QuadraticBezier.a({vd:this.m_geometry.getDescription()})}}bufferPolygonImpl(e,t,s){const i=e,n=i.getImpl();let r=new QuadraticBezier.a({vd:e.getDescription()});for(let m=t;m<s;m++){if(n.getPathSize(m)<1)continue;const t=n.calculateRingArea2D(m),s=new Envelope2D.J;if(n.queryPathEnvelope(m,s),this.m_distance>0)if(t>0)if(this.isDegeneratePath(n,m)){const e=new Envelope.P;n.getPointByVal(n.getPathStart(m),e),e.setXY(s.getCenter()),r.add(this.bufferDegeneratePath(e,!0),!1)}else{const t=new QuadraticBezier.P({vd:e.getDescription()}),s=t.getImpl();if((0,QuadraticBezier.i)(this.m_geometry,m)){const e=this.bufferConvexPath(i,m);r.add(e,!1)}else{this.bufferClosedPath(this.m_geometry,m,s,this.m_bRoundBuffer,1);const e=this.bufferCleanup(t);r.add(e,!1)}}else{if(s.width()+this.m_tolerance.total()<=2*this.m_absDistance||s.height()+this.m_tolerance.total()<=2*this.m_absDistance)continue;const t=new QuadraticBezier.P({vd:e.getDescription()}),i=t.getImpl();if(this.bufferClosedPath(this.m_geometry,m,i,this.m_bRoundBuffer,1),!t.isEmpty()){const e=s,n=Math.max(1,this.m_absDistance),m=e.clone();m.inflateCoords(n,n),i.addEnvelope(m,!1);const o=this.bufferCleanup(t);r.reserve(r.getPointCount()+o.getPointCount()-4),re(o,r,m,!0)}}else if(t>0){if(s.width()+this.m_tolerance.total()<=2*this.m_absDistance||s.height()+this.m_tolerance.total()<=2*this.m_absDistance)continue;const t=new QuadraticBezier.P({vd:e.getDescription()}),i=t.getImpl();if(this.bufferClosedPath(this.m_geometry,m,i,this.m_bRoundBuffer,-1),!t.isEmpty()){const e=new Envelope2D.J;i.queryLooseEnvelope(e);const s=Math.max(1,this.m_absDistance),n=e.clone();n.inflateCoords(s,s),i.addEnvelope(n,!1),re(this.bufferCleanup(t),r,n,!0)}}else{const t=new QuadraticBezier.P({vd:e.getDescription()}),s=t.getImpl();this.bufferClosedPath(this.m_geometry,m,s,this.m_bRoundBuffer,-1);const i=this.bufferCleanup(t);for(let e=0,n=i.getPathCount();e<n;e++)r.addPath(i,e,!0)}}if(this.m_distance>0)return r.getPathCount()>1?this.bufferCleanup(r):$(r);{const e=new Envelope2D.J;if(r.queryLooseEnvelope(e),r.isEmpty())return $(r);{const t=Math.max(1,this.m_absDistance),s=e.clone();s.inflateCoords(t,t),r.addEnvelope(s,!1);const i=this.bufferCleanup(r);r=new QuadraticBezier.a;const n=new QuadraticBezier.a({vd:i.getDescription()});return re(i,n,s,!1),$(n)}}}bufferPoint(){return this.bufferPointImpl(this.m_geometry)}bufferPointImpl(e){const t=new QuadraticBezier.a({vd:e.getDescription()});return 0===this.m_caps?(this.addCircle(t.getImpl(),e),this.setStrongSimple(t)):2===this.m_caps?(this.addSquare(t.getImpl(),e),this.setStrongSimple(t)):t}bufferDegeneratePath(e,t){const s=new QuadraticBezier.a({vd:e.getDescription()});return t&&0===this.m_joins||!t&&0===this.m_caps?(this.addCircle(s.getImpl(),e),this.setStrongSimple(s)):t||2!==this.m_caps?s:(this.addSquare(s.getImpl(),e),this.setStrongSimple(s))}bufferMultiPoint(){const e=new Q(this,this.m_geometry,this.m_distance,this.m_spatialReference,this.m_joins,this.m_caps,this.m_miterLimit,this.m_densifyDist,this.m_maxVertexInCompleteCircle,this.m_progressTracker);return(new ProjectionTransformation.h).executeMany(e,this.m_spatialReference,this.m_progressTracker,2).next()}bufferEnvelope(){let e=new QuadraticBezier.a({vd:this.m_geometry.getDescription()});if(this.m_distance<=0){if(0===this.m_distance)e.addEnvelope(this.m_geometry,!1),ee(this.m_geometry,this.m_tolerance.total())&&(e=this.setStrongSimple(e));else{const t=new Envelope.E;this.m_geometry.queryEnvelope(t),t.inflateCoords(this.m_distance,this.m_distance),e.addEnvelope(t,!1),ee(t,this.m_tolerance.total())&&(e=this.setStrongSimple(e))}return e}if(1===this.m_joins){const t=new Envelope.E({copy:this.m_geometry});return t.inflateCoords(this.m_absDistance,this.m_absDistance),e.addEnvelope(t,!1),e}const t=this.m_geometry.clone();if(0===t.width()||0===t.height()){if(0===t.width()&&0===t.height()){const e=new Envelope.P({vd:this.m_geometry.getDescription()});return t.queryCornerByVal(0,e),this.m_geometry=e,this.bufferImpl()}const e=new QuadraticBezier.P({vd:this.m_geometry.getDescription()}),s=new Envelope.P;return t.queryCornerByVal(0,s),e.startPathPoint(s),t.queryCornerByVal(2,s),e.lineToPoint(s),this.m_geometry=e,this.bufferImpl()}return e.addEnvelope(this.m_geometry,!1),this.m_geometry=e,this.bufferConvexPath(e,0)}bufferConvexPath(e,t){this.generateCircleTemplate();const i=e.hasAttribute(10),n=new QuadraticBezier.a({vd:e.getDescription()}),r=n.getImpl();n.reserve((this.m_circleTemplate.length/10+4)*e.getPathSize(t));const m=new Point2D.P,o=new Point2D.P,a=new Point2D.P,h=new Point2D.P(0,0),l=new Point2D.P,c=new Point2D.P,u=e.getImpl(),f=e.getPathSize(t),_=e.getPathStart(t);for(let g=0,d=e.getPathSize(t);g<d;g++){const e=u.getXY(_+g),t=u.getXY(_+(g+1)%f),n=u.getXY(_+(g+2)%f);l.setSub(t,e),0===l.length()&&(0,Geometry.c)("");const d=i&&!!(1&u.getAttributeAsInt(10,(g+1)%f,0));l.normalize();const p=l.clone();l.leftPerpendicularThis(),l.scale(this.m_absDistance),m.setAdd(l,e),o.setAdd(l,t),0===g?r.startPath(m):r.lineTo(m),r.lineTo(o),c.setSub(n,t),0===c.length()&&(0,Geometry.c)(""),c.normalize();const y=c.clone();c.leftPerpendicularThis(),c.scale(this.m_absDistance),a.setAdd(c,t);let b=O.enumArc;const P=d?0:this.m_joins;if(2===P)b=O.enumBevel;else if(1===P){const e=-p.crossProduct(y);h.setSub(p,y),h.scale(this.m_absDistance/e),h.length()<this.m_miterLimit*this.m_absDistance?(h.addThis(t),b=O.enumMiter):b=O.enumBevel}else h.assign(t);this.addJoin(b,r,h,o,a,!1,!1)}return $(n)}bufferPolylinePath(e,t,s){this.generateCircleTemplate();const i=e,n=i.getImpl();if(n.getPathSize(t)<1)return null;let r;if(r=this.m_bRoundBuffer?n.isClosedPathInXYPlane(t):n.isClosedPath(t),this.isDegeneratePath(n,t)&&this.m_distance>0){const e=new Envelope.P;n.getPointByVal(n.getPathStart(t),e);const s=new Envelope2D.J;return n.queryPathEnvelope(t,s),e.setXY(s.getCenter()),this.bufferDegeneratePath(e,r)}const m=new QuadraticBezier.P({vd:e.getDescription()});m.reserve((Math.trunc(this.m_circleTemplate.length/10)+4)*n.getPathSize(t));const o=m.getImpl();return r?2!==this.bufferClosedPath(i,t,o,s,1)&&this.bufferClosedPath(i,t,o,s,-1):this.bufferOpenPath(i,t,o,s),this.bufferCleanup(m)}progress_(){}bufferCleanup(e,t=!1){const s=t?this.m_tolerance:this.m_smallTolerance;return(0,ProjectionTransformation.y)(e,s,!0,!t,-1,this.m_progressTracker,0,!1)}calcN(){if(0===this.m_densifyDist)return this.m_maxVertexInCompleteCircle;const t=1-this.m_densifyDist*Math.abs(this.m_absDistanceReversed);let s=4;return s=t<-1?4:2*Math.PI/Math.acos(t)+.5,s<4?s=4:s>this.m_maxVertexInCompleteCircle&&(s=this.m_maxVertexInCompleteCircle),Math.trunc(s)}addJoin(e,t,s,i,n,r,m){if(this.generateCircleTemplate(),r&&(t.startPath(i),r=!1),e===O.enumBevel)return void(m&&t.lineTo(n));if(e===O.enumMiter){const e=s.clone();return t.lineTo(e),void(m&&t.lineTo(n))}const o=new Point2D.P;o.setSub(i,s),o.scale(this.m_absDistanceReversed);const a=new Point2D.P;a.setSub(n,s),a.scale(this.m_absDistanceReversed);let h=Math.atan2(o.y,o.x)/this.m_dA;h<0&&(h=this.m_circleTemplate.length+h),h=this.m_circleTemplate.length-h;let l=Math.atan2(a.y,a.x)/this.m_dA;l<0&&(l=this.m_circleTemplate.length+l),l=this.m_circleTemplate.length-l,l<h&&(l+=this.m_circleTemplate.length);let c=Math.trunc(l),u=Math.ceil(h),f=this.m_circleTemplate[u%this.m_circleTemplate.length].clone();f.scaleAddThis(this.m_absDistance,s);const _=10*this.m_tolerance.total();f.sub(i).length()<_&&(u+=1),f=this.m_circleTemplate[c%this.m_circleTemplate.length].clone(),f.scaleAddThis(this.m_absDistance,s),f.sub(n).length()<_&&(c-=1);let g=c-u;g++;for(let d=0,p=u%this.m_circleTemplate.length;d<g;d++,p=(p+1)%this.m_circleTemplate.length)f=this.m_circleTemplate[p].clone(),f.scaleAddThis(this.m_absDistance,s),t.lineTo(f),this.progress_();m&&t.lineTo(n)}bufferClosedPath(e,t,s,i,n){const r=new QuadraticBezier.E,m=r.addPathFromMultiPath(e,t,!0);return this.bufferClosedPathImpl(r,m,s,i,n)}bufferClosedPathImpl(e,t,s,i,n){const r=e.getFirstVertex(e.getFirstPath(t)),m=new Envelope.P;if(e.queryPoint(r,m),e.filterClosePoints(this.m_filterTolerance,!1,!1,!1,-1),e.getPointCount(t)<2)return n<0?0:(this.m_bRoundBuffer&&this.addCircle(s,m),2);(0,Geometry.g)(e.getFirstPath(t)!==QuadraticBezier.n),(0,Geometry.g)(e.getFirstVertex(e.getFirstPath(t))!==QuadraticBezier.n);const o=e.getXY(e.getFirstVertex(e.getFirstPath(t))),a=new Transformation2D.T;if(a.setShift(o.negate()),e.applyTransformation(a),i){const i=function ne(e,t,s,i,n,r,m){return function ie(s,i,n,r,m,o,a){const h={stack:[],error:void 0,hasError:!1};try{const t=s.getFirstPath(i),r=s.createUserIndex();(0,tslib_es6.b)(h,(0,Point2D.h)((()=>{s.removeUserIndex(r)}),!1),!1),function se(e,t,s,i){let n=-1;const r=new Point2D.P,m=new Point2D.P,o=new Point2D.P;for(let a=0,h=e.getPathSize(i),l=e.getFirstVertex(i);a<h;++a){-1===n&&(e.queryXY(l,m),n=e.getPrevVertex(l),-1!==n&&(e.queryXY(n,r),o.setSub(m,r),o.normalize()));const s=e.getNextVertex(l);if(-1===s)break;const i=e.getXY(s),a=i.sub(m);a.normalize(),-1!==n&&a.dotProduct(o)<-.99&&Math.abs(a.crossProduct(o))<1e-7&&e.setUserIndex(l,t,1),n=l,l=s,r.assign(m),m.assign(i),o.assign(a)}}(s,r,0,t);for(let e=0;e<100;++e){if(0===s.getPathSize(t))return 1;let e=s.getFirstVertex(t),i=s.getPathSize(t);if(i<3)return 1;s.isClosedPath(t)||(i-=1);const o=64;let h=0,l=!1;for(let t=0;t<i&&e!==QuadraticBezier.n;t++){let c=0,u=e;for(let h=1,l=Math.min(o,i-t);h<l;h++)if(u=s.getNextVertexEx(u,n),h>1){const t=te(s,r,e,u,n,m,a,o);if(-1===t)break;c+=t,i-=t}if(h+=c,l=c>0,l){const t=s.getPrevVertexEx(e,n);if(-1!==t){e=t,i++;continue}}e=s.getNextVertexEx(e,n)}if(0===h)break}return s.filterClosePoints(o,!1,!1,!1,-1),1}catch(l){h.error=l,h.hasError=!0}finally{(0,tslib_es6.c)(h)}}(e,t,s,0,n,r,m)}(e,t,n,0,this.m_absDistance,this.m_filterTolerance,this.m_densifyDist);if((0,Geometry.g)(1===i),e.getPointCount(t)<2)return n<0?0:(this.addCircle(s,m),2)}const h=0!==this.m_joins&&e.getVertexDescription().hasAttribute(10);this.m_bufferCommands.length=0;const l=e.getFirstPath(t);let c=e.getFirstVertex(l),u=1===n?e.getPrevVertex(c):e.getNextVertex(c),_=1===n?e.getNextVertex(c):e.getPrevVertex(c),g=!0;const d=new Point2D.P,p=new Point2D.P,b=new Point2D.P,P=new Point2D.P,x=new Point2D.P,C=new Point2D.P,w=new Point2D.P,T=new Point2D.P,v=this.m_absDistance,S=e.getPathSize(l),I=new Point2D.P(0,0);for(let f=0;f<S;f++){p.assign(e.getXY(_)),g&&(d.assign(e.getXY(c)),b.assign(e.getXY(u)),C.setSub(d,b),C.normalize(),T.leftPerpendicularOther(C),T.scale(v),P.setAdd(T,d));const t=h&&!!(1&e.getAttributeAsDbl(10,c,0));x.setSub(p,d),x.normalize(),w.leftPerpendicularOther(x),w.scale(v);const s=new Point2D.P;s.setAdd(d,w);const i=C.crossProduct(x),r=C.dotProduct(x);if(i<0||r<0&&i<Math.abs(r)*Number.EPSILON*8){let e=!1;const n=t?0:this.m_joins;if(1===n){const t=-i;I.setSub(C,x),I.scale(this.m_absDistance/t),I.length()<this.m_miterLimit*this.m_absDistance&&(I.addThis(d),e=!0),this.m_bufferCommands.push(J(P,s,I,e?O.enumMiter:O.enumBevel,this.m_bufferCommands.length+1))}else this.m_bufferCommands.push(J(P,s,d,0===n?O.enumArc:O.enumBevel,this.m_bufferCommands.length+1))}else P.equals(s)||(this.m_bufferCommands.push(U(P,d,this.m_bufferCommands.length+1)),this.m_bufferCommands.push(U(d,s,this.m_bufferCommands.length+1)));const m=new Point2D.P;m.setAdd(p,w),this.m_bufferCommands.push(J(s,m,d,O.enumLine,this.m_bufferCommands.length+1)),P.setCoordsPoint2D(m),T.setCoordsPoint2D(w),b.setCoordsPoint2D(d),d.setCoordsPoint2D(p),C.setCoordsPoint2D(x),u=c,c=_,g=!1,_=1===n?e.getNextVertex(c):e.getPrevVertex(c)}return this.m_bufferCommands.at(-1).m_next=0,this.processBufferCommands(s),a.setShift(o),s.applyTransformationToPath(a,s.getPathCount()-1),1}bufferOpenPath(e,t,s,i){if(this.m_bRoundBuffer){const n=new QuadraticBezier.P({vd:e.getDescription()});return n.addPath(e,t,!1),n.addSegmentsFromPath(e,t,0,e.getSegmentCountPath(t),!1),this.bufferClosedPath(n,0,s,i,1)}let n=0;const r=new QuadraticBezier.P({vd:e.getDescription()}),m=new Point2D.P(0,0);{const i=new QuadraticBezier.E,o=i.addPathFromMultiPath(e,t,!1),a=i.getFirstVertex(i.getFirstPath(o)),h=new Envelope.P;if(i.queryPoint(a,h),m.assign(h.getXY()),i.filterClosePoints(0,!1,!1,!1,-1),i.getPointCount(o)<2)return this.m_bRoundBuffer&&this.addCircle(s,h),2;const l=i.getGeometry(i.getFirstGeometry());r.addPath(l,0,!1),n=r.getPointCount()-1,r.addSegmentsFromPath(l,0,0,l.getSegmentCountPath(0)-1,!1)}const o=new QuadraticBezier.E,a=o.addPathFromMultiPath(r,0,!0);(0,Geometry.g)(o.getFirstPath(a)!==QuadraticBezier.n),(0,Geometry.g)(o.getFirstVertex(o.getFirstPath(a))!==QuadraticBezier.n);const h=new Transformation2D.T;h.setShift(m.negate()),o.applyTransformation(h),this.m_bufferCommands.length=0;const l=o.getFirstPath(a),c=0!==this.m_joins&&o.getVertexDescription().hasAttribute(10);let u=o.getFirstVertex(l),_=o.getPrevVertex(u),g=o.getNextVertex(u),d=!0;const p=new Point2D.P,b=new Point2D.P,P=new Point2D.P,x=new Point2D.P,C=new Point2D.P,w=new Point2D.P,T=new Point2D.P,v=new Point2D.P,S=this.m_absDistance,I=o.getPathSize(l),M=new Point2D.P(0,0);for(let f=0;f<I;f++){let e=!1;0!==f&&f!==n||(e=!0),b.assign(o.getXY(g)),d&&(p.assign(o.getXY(u)),P.assign(o.getXY(_)),w.setSub(p,P),w.normalize(),v.leftPerpendicularOther(w),v.scale(S),x.setAdd(v,p));const t=c&&!!(1&o.getAttributeAsDbl(10,u,0));C.setSub(b,p),C.normalize(),T.leftPerpendicularOther(C),T.scale(S);const s=new Point2D.P;s.setAdd(p,T);const i=w.crossProduct(C),r=w.dotProduct(C);if(i<0||r<0&&i<Math.abs(r)*Number.EPSILON*8)if(e)if(0===this.m_caps)this.m_bufferCommands.push(J(x,s,p,O.enumArc,this.m_bufferCommands.length+1));else if(1===this.m_caps)this.m_bufferCommands.push(J(x,s,p,O.enumLine,this.m_bufferCommands.length+1));else{const e=C.mul(this.m_absDistance).negate(),t=e.clone();e.addThis(x),t.addThis(s),this.m_bufferCommands.push(J(x,e,p,O.enumLine,this.m_bufferCommands.length+1)),this.m_bufferCommands.push(J(e,t,p,O.enumLine,this.m_bufferCommands.length+1)),this.m_bufferCommands.push(J(t,s,p,O.enumLine,this.m_bufferCommands.length+1))}else{let e=!1;const n=t?0:this.m_joins;if(1===n){const t=-i;M.setSub(w,C),M.scale(this.m_absDistance/t),M.length()<this.m_miterLimit*this.m_absDistance&&(M.addThis(p),e=!0),this.m_bufferCommands.push(J(x,s,M,e?O.enumMiter:O.enumBevel,this.m_bufferCommands.length+1))}else this.m_bufferCommands.push(J(x,s,p,0===n?O.enumArc:O.enumBevel,this.m_bufferCommands.length+1))}else x.equals(s)||(this.m_bufferCommands.push(U(x,p,this.m_bufferCommands.length+1)),this.m_bufferCommands.push(U(p,s,this.m_bufferCommands.length+1)));const m=new Point2D.P;m.setAdd(b,T),this.m_bufferCommands.push(J(s,m,p,O.enumLine,this.m_bufferCommands.length+1)),x.setCoordsPoint2D(m),v.setCoordsPoint2D(T),P.setCoordsPoint2D(p),p.setCoordsPoint2D(b),w.setCoordsPoint2D(C),_=u,u=g,d=!1,g=o.getNextVertex(u)}return this.m_bufferCommands.at(-1).m_next=0,this.processBufferCommands(s),h.setShift(m),s.applyTransformationToPath(h,s.getPathCount()-1),1}processBufferCommands(e){const t=this.cleanupBufferCommands();let s=!0,i=t+1;for(let n=t;i!==t;n=i){const t=this.m_bufferCommands[n];i=-1!==t.m_next?t.m_next:(n+1)%this.m_bufferCommands.length,t.m_type&&(s&&(e.startPath(t.m_from),s=!1),t.m_type&O.enumJoinMask?this.addJoin(t.m_type,e,t.m_center,t.m_from,t.m_to,!1,!0):e.lineTo(t.m_to))}}cleanupBufferCommands(){this.m_helperArray=(0,Point2D.m)(Point2D.P,9);let e=0;for(let s=0,i=this.m_bufferCommands.length;s<i;){const t=this.m_bufferCommands[s];if(t.m_type&O.enumConnectionMask){e=s;break}s=t.m_next}let t=e+1;for(let s=e;t!==e;s=t){const e=this.m_bufferCommands[s];t=e.m_next;let i=1,n=null;for(;t!==s&&(n=this.m_bufferCommands[t],!(n.m_type&O.enumConnectionMask));)t=n.m_next,i++;1!==i&&(e.m_type&n.m_type)===O.enumLine&&(this.m_helperLine1.setStartXY(e.m_from),this.m_helperLine1.setEndXY(e.m_to),this.m_helperLine2.setStartXY(n.m_from),this.m_helperLine2.setEndXY(n.m_to),1===this.m_helperLine1.intersect(this.m_helperLine2,this.m_helperArray,null,null,this.m_smallTolerance.total())&&(e.m_to.assign(this.m_helperArray[0]),n.m_from.assign(this.m_helperArray[0]),e.m_next=t))}return e}isDegeneratePath(e,t){if(1===e.getPathSize(t))return!0;if(0===this.m_joins&&0===this.m_caps){const s=new Envelope2D.J;if(e.queryPathEnvelope(t,s),Math.max(s.width(),s.height())<.5*this.m_densifyDist)return!0}return!1}isDegenerateGeometry(e){if(0===this.m_joins&&0===this.m_caps){const t=new Envelope2D.J;if(e.queryEnvelope(t),Math.max(t.width(),t.height())<.5*this.m_densifyDist)return!0}return!1}addCircle(e,t){const s=t.getXY();if(0!==this.m_circleTemplate.length){let t=this.m_circleTemplate[0].clone();t.scaleAddThis(this.m_absDistance,s),e.startPath(t);for(let i=1,n=this.m_circleTemplate.length;i<n;i++)t=this.m_circleTemplate[i].clone(),t.scaleAddThis(this.m_absDistance,s),e.lineTo(t);return}const i=this.m_circleTemplateSize,n=Math.trunc((i+3)/4),r=.5*Math.PI/n;e.reserve(4*n);const m=Math.cos(r),o=Math.sin(r);for(let a=3;a>=0;a--){const t=Point2D.P.construct(0,this.m_absDistance);switch(a){case 0:for(let i=0;i<n;i++)e.lineToCoords(t.x+s.x,t.y+s.y),t.rotateReverse(m,o);break;case 1:for(let i=0;i<n;i++)e.lineToCoords(-t.y+s.x,t.x+s.y),t.rotateReverse(m,o);break;case 2:for(let i=0;i<n;i++)e.lineToCoords(-t.x+s.x,-t.y+s.y),t.rotateReverse(m,o);break;default:e.startPathCoords(t.y+s.x,-t.x+s.y);for(let i=1;i<n;i++)t.rotateReverse(m,o),e.lineToCoords(t.y+s.x,-t.x+s.y)}this.progress_()}}addSquare(e,t){const s=new Envelope.E({vd:t.getDescription()});s.setCoords(t.getX(),t.getY(),t.getX(),t.getY()),s.inflateCoords(this.m_absDistance,this.m_absDistance),e.addEnvelope(s,!1)}setStrongSimple(e){return e.getImpl().setIsSimple(4,this.m_tolerance.total()),e.getImpl().updateOGCFlagsProtected(),e}}function $(e){return(0,Envelope.s)(e,0),e}function ee(e,t){return!!e.isEmpty()||Math.min(e.width(),e.height())>t}function te(e,t,s,i,n,r,m,o){const a=e.getXY(s),h=e.getXY(i);if(a.equals(h))return-1;const l=.25*m,c=.25*m,u=new Point2D.P;u.setSub(h,a);const _=u.length(),g=_*_*.25,d=r*r-g;if(d<=g)return-1;const p=Math.sqrt(d);u.normalize();const y=u.clone();y.rightPerpendicularThis();const b=g/p,P=b<=c,x=Point2D.P.lerp(h,a,.5),C=y.clone(),w=b-l;C.scaleAddThis(Math.max(0,w),x),y.negate().scaleAddThis(p,x);const S=3.61*(0,Point2D.s)(r-c),I=C.sub(a),M=C.sub(h);let E=!1,V=0;const k=(0,Point2D.d)(64,0);(0,Geometry.g)(o===k.length);{for(let o=e.getPrevVertexEx(i,n);o!==s;){if(1===e.getUserIndex(o,t))return-1;if(!e.getXY(o).equals(h))break;{const t=e.getPrevVertexEx(o,n);e.removeVertex(o,!1),o=t}}const r=new Point2D.P,m=a.clone();k[V++]=1;for(let o=e.getNextVertexEx(s,n);o!==i;){if(1===e.getUserIndex(o,t))return-1;const s=e.getXY(o);if(s.equals(m)){const t=e.getNextVertexEx(o,n);e.removeVertex(o,!1),o=t;continue}k[V++]=0;const i=new Point2D.P;if(i.setSub(s,a),i.dotProduct(y)<0)return 0;(Point2D.P.sqrDistance(s,a)>S||Point2D.P.sqrDistance(s,h)>S)&&(E=!0);let l=0;if(s.sub(a).crossProduct(I)>=0&&(l=1),s.sub(h).crossProduct(M)<=0&&(l|=2),0===l)return 0;k[V-1]=l,r.assign(m),m.assign(s),o=e.getNextVertexEx(o,n)}if(1===V)return 0;(0,Geometry.g)(V<k.length),k[V++]=2}let R=!0;for(let f=1,D=0;f<V;f++)if(k[f]!==k[f-1]&&(D++,R=D<3&&(1===D&&3===k[f]||2===D&&2===k[f]),!R))return 0;if(V>2&&R&&(3===V||!E)){let t=0,r=e.getNextVertexEx(s,n);for(P||(e.setXY(r,C),r=e.getNextVertexEx(r,n));r!==i;){const s=e.getNextVertexEx(r,n);e.removeVertex(r,!1),r=s,++t}return t}if((0,Geometry.g)(3!==V),E&&V>3)return 0;const B=a.clone();let A=s;const X=a.clone();let Y=1,F=-1,G=A,j=0;for(V=1;G!==i;){G=e.getNextVertexEx(G,n);const t=k[V++];if(0===t){if(G===i)break;continue}const s=e.getXY(G);if(-1!==F){if(F&Y&t&3){e.removeVertex(A,!0),j++,A=G,X.setCoordsPoint2D(s),Y=t;continue}if(3===Y&&0!==F&&0!==t){if(X.setCoordsPoint2D(C),P||X.equals(B)){e.removeVertex(A,!0),j++,A=G,X.setCoordsPoint2D(s),Y=t;continue}e.setXY(A,X)}}F=Y,B.setCoordsPoint2D(X),A=G,Y=t,X.setCoordsPoint2D(s)}return j}function re(e,t,s,i){for(let n=0,r=e.getPathCount();n<r;n++){const r=e.getXY(e.getPathStart(n));r.x!==s.xmin&&r.x!==s.xmax&&t.addPath(e,n,i)}}class c extends SimpleGeometryCursor.G{constructor(e,t,r,n,s,i,m){super(),this.m_currentUnionEnvelope2D=new Envelope2D.J,this.m_index=-1,this.m_dindex=-1,this.m_progressTracker=m,this.m_bufferer=new Z(m),this.m_inputGeoms=e,this.m_spatialReference=t,this.m_distances=r,this.m_maxDeviation=n,this.m_maxVerticesInFullCircle=s}tock(){return!0}getRank(){return 1}next(){{let e;for(;e=this.m_inputGeoms.next();)return(0,Geometry.d)(e),this.m_index=this.m_inputGeoms.getGeometryID(),this.m_dindex+1<this.m_distances.length&&this.m_dindex++,this.buffer(e,this.m_distances[this.m_dindex]);return null}}getGeometryID(){return this.m_index}buffer(e,t){return this.m_bufferer.buffer(e,t,this.m_spatialReference,0,0,4,this.m_maxDeviation,this.m_maxVerticesInFullCircle)}}const a=new class m{getOperatorType(){return 10004}supportsCurves(){return!0}accelerateGeometry(e,t,r){return!1}canAccelerateGeometry(e){return!1}executeMany(e,t,r,n,s){return this.executeManyEx(e,t,r,Number.NaN,96,n,s)}execute(t,s,i,u){Number.isFinite(i)||(0,Geometry.t)("Invalid distance for buffer operation");const o=new SimpleGeometryCursor.S([t]),m=[i],c=this.executeMany(o,s,m,!1,u).next();return c||(0,Geometry.c)("null buffer output"),c}executeManyEx(e,t,n,s,u,o,m){if(void 0!==n.find((e=>!Number.isFinite(e)))&&(0,Geometry.t)("Invalid distance for buffer operation"),o){const r=new c(e,t,n,s,u,!1,m);return(new ProjectionTransformation.h).executeMany(r,t,m,2)}return new c(e,t,n,s,u,!1,m)}};function f(e,t,r){return a.execute(e,t,r,null)}function l(t,r,n,s,i,u){const o=a.executeManyEx(new SimpleGeometryCursor.S(t),r,n,s,i,u,null);return Array.from(o)}function x(){return a.supportsCurves()}}}]);