(self.webpackChunk_defra_flood_map=self.webpackChunk_defra_flood_map||[]).push([[688],{"./node_modules/@turf/area/dist/esm/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{W:()=>esm_area});var esm=__webpack_require__("./node_modules/@turf/helpers/dist/esm/index.js");function geomEach(geojson,callback){var i,j,g,geometry,stopG,geometryMaybeCollection,isGeometryCollection,featureProperties,featureBBox,featureId,featureIndex=0,isFeatureCollection="FeatureCollection"===geojson.type,isFeature="Feature"===geojson.type,stop=isFeatureCollection?geojson.features.length:1;for(i=0;i<stop;i++){for(geometryMaybeCollection=isFeatureCollection?geojson.features[i].geometry:isFeature?geojson.geometry:geojson,featureProperties=isFeatureCollection?geojson.features[i].properties:isFeature?geojson.properties:{},featureBBox=isFeatureCollection?geojson.features[i].bbox:isFeature?geojson.bbox:void 0,featureId=isFeatureCollection?geojson.features[i].id:isFeature?geojson.id:void 0,stopG=(isGeometryCollection=!!geometryMaybeCollection&&"GeometryCollection"===geometryMaybeCollection.type)?geometryMaybeCollection.geometries.length:1,g=0;g<stopG;g++)if(null!==(geometry=isGeometryCollection?geometryMaybeCollection.geometries[g]:geometryMaybeCollection))switch(geometry.type){case"Point":case"LineString":case"MultiPoint":case"Polygon":case"MultiLineString":case"MultiPolygon":if(!1===callback(geometry,featureIndex,featureProperties,featureBBox,featureId))return!1;break;case"GeometryCollection":for(j=0;j<geometry.geometries.length;j++)if(!1===callback(geometry.geometries[j],featureIndex,featureProperties,featureBBox,featureId))return!1;break;default:throw new Error("Unknown Geometry Type")}else if(!1===callback(null,featureIndex,featureProperties,featureBBox,featureId))return!1;featureIndex++}}function esm_area(geojson){return function geomReduce(geojson,callback,initialValue){var previousValue=initialValue;return geomEach(geojson,(function(currentGeometry,featureIndex,featureProperties,featureBBox,featureId){previousValue=0===featureIndex&&void 0===initialValue?currentGeometry:callback(previousValue,currentGeometry,featureIndex,featureProperties,featureBBox,featureId)})),previousValue}(geojson,((value,geom)=>value+function calculateArea(geom){let i,total=0;switch(geom.type){case"Polygon":return polygonArea(geom.coordinates);case"MultiPolygon":for(i=0;i<geom.coordinates.length;i++)total+=polygonArea(geom.coordinates[i]);return total;case"Point":case"MultiPoint":case"LineString":case"MultiLineString":return 0}return 0}(geom)),0)}function polygonArea(coords){let total=0;if(coords&&coords.length>0){total+=Math.abs(ringArea(coords[0]));for(let i=1;i<coords.length;i++)total-=Math.abs(ringArea(coords[i]))}return total}var FACTOR=esm.zX*esm.zX/2,PI_OVER_180=Math.PI/180;function ringArea(coords){const coordsLength=coords.length-1;if(coordsLength<=2)return 0;let total=0,i=0;for(;i<coordsLength;){const lower=coords[i],middle=coords[i+1===coordsLength?0:i+1],upper=coords[i+2>=coordsLength?(i+2)%coordsLength:i+2],lowerX=lower[0]*PI_OVER_180,middleY=middle[1]*PI_OVER_180;total+=(upper[0]*PI_OVER_180-lowerX)*Math.sin(middleY),i++}return total*FACTOR}},"./node_modules/@turf/bbox-clip/dist/esm/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{y:()=>bboxClip});var _turf_helpers__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/@turf/helpers/dist/esm/index.js"),_turf_invariant__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/@turf/invariant/dist/esm/index.js");function polygonclip(points,bbox){var result,edge,prev,prevInside,i,p,inside;for(edge=1;edge<=8;edge*=2){for(result=[],prevInside=!(bitCode(prev=points[points.length-1],bbox)&edge),i=0;i<points.length;i++)(inside=!(bitCode(p=points[i],bbox)&edge))!==prevInside&&result.push(intersect(prev,p,edge,bbox)),inside&&result.push(p),prev=p,prevInside=inside;if(!(points=result).length)break}return result}function intersect(a,b,edge,bbox){return 8&edge?[a[0]+(b[0]-a[0])*(bbox[3]-a[1])/(b[1]-a[1]),bbox[3]]:4&edge?[a[0]+(b[0]-a[0])*(bbox[1]-a[1])/(b[1]-a[1]),bbox[1]]:2&edge?[bbox[2],a[1]+(b[1]-a[1])*(bbox[2]-a[0])/(b[0]-a[0])]:1&edge?[bbox[0],a[1]+(b[1]-a[1])*(bbox[0]-a[0])/(b[0]-a[0])]:null}function bitCode(p,bbox){var code=0;return p[0]<bbox[0]?code|=1:p[0]>bbox[2]&&(code|=2),p[1]<bbox[1]?code|=4:p[1]>bbox[3]&&(code|=8),code}function bboxClip(feature,bbox){const geom=(0,_turf_invariant__WEBPACK_IMPORTED_MODULE_0__.bg)(feature),type=geom.type,properties="Feature"===feature.type?feature.properties:{};let coords=geom.coordinates;switch(type){case"LineString":case"MultiLineString":{const lines=[];return"LineString"===type&&(coords=[coords]),coords.forEach((line=>{!function lineclip(points,bbox,result){var i,codeB,lastCode,len=points.length,codeA=bitCode(points[0],bbox),part=[];let a,b;for(result||(result=[]),i=1;i<len;i++){for(a=points[i-1],b=points[i],codeB=lastCode=bitCode(b,bbox);;){if(!(codeA|codeB)){part.push(a),codeB!==lastCode?(part.push(b),i<len-1&&(result.push(part),part=[])):i===len-1&&part.push(b);break}if(codeA&codeB)break;codeA?(a=intersect(a,b,codeA,bbox),codeA=bitCode(a,bbox)):(b=intersect(a,b,codeB,bbox),codeB=bitCode(b,bbox))}codeA=lastCode}return part.length&&result.push(part),result}(line,bbox,lines)})),1===lines.length?(0,_turf_helpers__WEBPACK_IMPORTED_MODULE_1__.wi)(lines[0],properties):(0,_turf_helpers__WEBPACK_IMPORTED_MODULE_1__.NU)(lines,properties)}case"Polygon":return(0,_turf_helpers__WEBPACK_IMPORTED_MODULE_1__.n1)(clipPolygon(coords,bbox),properties);case"MultiPolygon":return(0,_turf_helpers__WEBPACK_IMPORTED_MODULE_1__.g5)(coords.map((poly=>clipPolygon(poly,bbox))),properties);default:throw new Error("geometry "+type+" not supported")}}function clipPolygon(rings,bbox){const outRings=[];for(const ring of rings){const clipped=polygonclip(ring,bbox);clipped.length>0&&(clipped[0][0]===clipped[clipped.length-1][0]&&clipped[0][1]===clipped[clipped.length-1][1]||clipped.push(clipped[0]),clipped.length>=4&&outRings.push(clipped))}return outRings}},"./node_modules/@turf/distance/dist/esm/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{I:()=>distance});var _turf_invariant__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/@turf/invariant/dist/esm/index.js"),_turf_helpers__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/@turf/helpers/dist/esm/index.js");function distance(from,to,options={}){var coordinates1=(0,_turf_invariant__WEBPACK_IMPORTED_MODULE_0__.uG)(from),coordinates2=(0,_turf_invariant__WEBPACK_IMPORTED_MODULE_0__.uG)(to),dLat=(0,_turf_helpers__WEBPACK_IMPORTED_MODULE_1__.tR)(coordinates2[1]-coordinates1[1]),dLon=(0,_turf_helpers__WEBPACK_IMPORTED_MODULE_1__.tR)(coordinates2[0]-coordinates1[0]),lat1=(0,_turf_helpers__WEBPACK_IMPORTED_MODULE_1__.tR)(coordinates1[1]),lat2=(0,_turf_helpers__WEBPACK_IMPORTED_MODULE_1__.tR)(coordinates2[1]),a=Math.pow(Math.sin(dLat/2),2)+Math.pow(Math.sin(dLon/2),2)*Math.cos(lat1)*Math.cos(lat2);return(0,_turf_helpers__WEBPACK_IMPORTED_MODULE_1__.cJ)(2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a)),options.units)}},"./node_modules/@turf/helpers/dist/esm/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{Gf:()=>lengthToRadians,NU:()=>multiLineString,cJ:()=>radiansToLength,g5:()=>multiPolygon,n1:()=>polygon,nv:()=>radiansToDegrees,tR:()=>degreesToRadians,wi:()=>lineString,zX:()=>earthRadius,zx:()=>point});var earthRadius=6371008.8,factors={centimeters:100*earthRadius,centimetres:100*earthRadius,degrees:360/(2*Math.PI),feet:3.28084*earthRadius,inches:39.37*earthRadius,kilometers:earthRadius/1e3,kilometres:earthRadius/1e3,meters:earthRadius,metres:earthRadius,miles:earthRadius/1609.344,millimeters:1e3*earthRadius,millimetres:1e3*earthRadius,nauticalmiles:earthRadius/1852,radians:1,yards:1.0936*earthRadius};function feature(geom,properties,options={}){const feat={type:"Feature"};return(0===options.id||options.id)&&(feat.id=options.id),options.bbox&&(feat.bbox=options.bbox),feat.properties=properties||{},feat.geometry=geom,feat}function point(coordinates,properties,options={}){if(!coordinates)throw new Error("coordinates is required");if(!Array.isArray(coordinates))throw new Error("coordinates must be an Array");if(coordinates.length<2)throw new Error("coordinates must be at least 2 numbers long");if(!isNumber(coordinates[0])||!isNumber(coordinates[1]))throw new Error("coordinates must contain numbers");return feature({type:"Point",coordinates},properties,options)}function polygon(coordinates,properties,options={}){for(const ring of coordinates){if(ring.length<4)throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");if(ring[ring.length-1].length!==ring[0].length)throw new Error("First and last Position are not equivalent.");for(let j=0;j<ring[ring.length-1].length;j++)if(ring[ring.length-1][j]!==ring[0][j])throw new Error("First and last Position are not equivalent.")}return feature({type:"Polygon",coordinates},properties,options)}function lineString(coordinates,properties,options={}){if(coordinates.length<2)throw new Error("coordinates must be an array of two or more positions");return feature({type:"LineString",coordinates},properties,options)}function multiLineString(coordinates,properties,options={}){return feature({type:"MultiLineString",coordinates},properties,options)}function multiPolygon(coordinates,properties,options={}){return feature({type:"MultiPolygon",coordinates},properties,options)}function radiansToLength(radians,units="kilometers"){const factor=factors[units];if(!factor)throw new Error(units+" units is invalid");return radians*factor}function lengthToRadians(distance,units="kilometers"){const factor=factors[units];if(!factor)throw new Error(units+" units is invalid");return distance/factor}function radiansToDegrees(radians){return 180*(radians%(2*Math.PI))/Math.PI}function degreesToRadians(degrees){return degrees%360*Math.PI/180}function isNumber(num){return!isNaN(num)&&null!==num&&!Array.isArray(num)}},"./node_modules/@turf/invariant/dist/esm/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";function getCoord(coord){if(!coord)throw new Error("coord is required");if(!Array.isArray(coord)){if("Feature"===coord.type&&null!==coord.geometry&&"Point"===coord.geometry.type)return[...coord.geometry.coordinates];if("Point"===coord.type)return[...coord.coordinates]}if(Array.isArray(coord)&&coord.length>=2&&!Array.isArray(coord[0])&&!Array.isArray(coord[1]))return[...coord];throw new Error("coord must be GeoJSON Point or an Array of numbers")}function getGeom(geojson){return"Feature"===geojson.type?geojson.geometry:geojson}__webpack_require__.d(__webpack_exports__,{bg:()=>getGeom,uG:()=>getCoord})},"./node_modules/computed-style-to-inline-style/dist/index.js":function(module){module.exports=(()=>{"use strict";var e={};return(()=>{var t=e;Object.defineProperty(t,"__esModule",{value:!0}),t.default=function e(t,o){if(!t)throw new Error("No element specified.");(null==o?void 0:o.recursive)&&Array.prototype.forEach.call(t.children,(t=>{e(t,o)}));const r=getComputedStyle(t);Array.prototype.forEach.call((null==o?void 0:o.properties)||r,(e=>{t.style[e]=r.getPropertyValue(e)}))}})(),e})()},"./node_modules/polylabel/polylabel.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{A:()=>polylabel});class TinyQueue{constructor(data=[],compare=(a,b)=>a<b?-1:a>b?1:0){if(this.data=data,this.length=this.data.length,this.compare=compare,this.length>0)for(let i=(this.length>>1)-1;i>=0;i--)this._down(i)}push(item){this.data.push(item),this._up(this.length++)}pop(){if(0===this.length)return;const top=this.data[0],bottom=this.data.pop();return--this.length>0&&(this.data[0]=bottom,this._down(0)),top}peek(){return this.data[0]}_up(pos){const{data,compare}=this,item=data[pos];for(;pos>0;){const parent=pos-1>>1,current=data[parent];if(compare(item,current)>=0)break;data[pos]=current,pos=parent}data[pos]=item}_down(pos){const{data,compare}=this,halfLength=this.length>>1,item=data[pos];for(;pos<halfLength;){let bestChild=1+(pos<<1);const right=bestChild+1;if(right<this.length&&compare(data[right],data[bestChild])<0&&(bestChild=right),compare(data[bestChild],item)>=0)break;data[pos]=data[bestChild],pos=bestChild}data[pos]=item}}function polylabel(polygon,precision=1,debug=!1){let minX=1/0,minY=1/0,maxX=-1/0,maxY=-1/0;for(const[x,y]of polygon[0])x<minX&&(minX=x),y<minY&&(minY=y),x>maxX&&(maxX=x),y>maxY&&(maxY=y);const width=maxX-minX,height=maxY-minY,cellSize=Math.max(precision,Math.min(width,height));if(cellSize===precision){const result=[minX,minY];return result.distance=0,result}const cellQueue=new TinyQueue([],((a,b)=>b.max-a.max));let bestCell=function getCentroidCell(polygon){let area=0,x=0,y=0;const points=polygon[0];for(let i=0,len=points.length,j=len-1;i<len;j=i++){const a=points[i],b=points[j],f=a[0]*b[1]-b[0]*a[1];x+=(a[0]+b[0])*f,y+=(a[1]+b[1])*f,area+=3*f}const centroid=new Cell(x/area,y/area,0,polygon);return 0===area||centroid.d<0?new Cell(points[0][0],points[0][1],0,polygon):centroid}(polygon);const bboxCell=new Cell(minX+width/2,minY+height/2,0,polygon);bboxCell.d>bestCell.d&&(bestCell=bboxCell);let numProbes=2;function potentiallyQueue(x,y,h){const cell=new Cell(x,y,h,polygon);numProbes++,cell.max>bestCell.d+precision&&cellQueue.push(cell),cell.d>bestCell.d&&(bestCell=cell,debug&&console.log(`found best ${Math.round(1e4*cell.d)/1e4} after ${numProbes} probes`))}let h=cellSize/2;for(let x=minX;x<maxX;x+=cellSize)for(let y=minY;y<maxY;y+=cellSize)potentiallyQueue(x+h,y+h,h);for(;cellQueue.length;){const{max,x,y,h:ch}=cellQueue.pop();if(max-bestCell.d<=precision)break;h=ch/2,potentiallyQueue(x-h,y-h,h),potentiallyQueue(x+h,y-h,h),potentiallyQueue(x-h,y+h,h),potentiallyQueue(x+h,y+h,h)}debug&&console.log(`num probes: ${numProbes}\nbest distance: ${bestCell.d}`);const result=[bestCell.x,bestCell.y];return result.distance=bestCell.d,result}function Cell(x,y,h,polygon){this.x=x,this.y=y,this.h=h,this.d=function pointToPolygonDist(x,y,polygon){let inside=!1,minDistSq=1/0;for(const ring of polygon)for(let i=0,len=ring.length,j=len-1;i<len;j=i++){const a=ring[i],b=ring[j];a[1]>y!=b[1]>y&&x<(b[0]-a[0])*(y-a[1])/(b[1]-a[1])+a[0]&&(inside=!inside),minDistSq=Math.min(minDistSq,getSegDistSq(x,y,a,b))}return 0===minDistSq?0:(inside?1:-1)*Math.sqrt(minDistSq)}(x,y,polygon),this.max=this.d+this.h*Math.SQRT2}function getSegDistSq(px,py,a,b){let x=a[0],y=a[1],dx=b[0]-x,dy=b[1]-y;if(0!==dx||0!==dy){const t=((px-x)*dx+(py-y)*dy)/(dx*dx+dy*dy);t>1?(x=b[0],y=b[1]):t>0&&(x+=dx*t,y+=dy*t)}return dx=px-x,dy=py-y,dx*dx+dy*dy}}}]);